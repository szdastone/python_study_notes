{"./":{"url":"./","title":"简介","keywords":"","body":"简介 个人学习Python的学习记录！ © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"install/":{"url":"install/","title":"安装","keywords":"","body":"安装 要安装python，那么就需要去官网先了解，链接如下： 【官方网站】：http://python.org 【下载网址】：https://www.python.org/downloads 当前的版本为3.7.3，那我们就以这个版本为准进行安装以及后面的学习！ 另外提供一些python学习网站： 【第三方库】：https://pypi.python.org/pypi 【官方文档】：https://docs.python.org/zh-cn/3/ 【中文教程】：http://www.runoob.com/python3/python3-tutorial.html 【Awesome Python】：https://github.com/vinta/awesome-python 【Awesome Python中文版】：https://github.com/jobbole/awesome-python-cn 【廖雪峰的Python教程】：https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"install/install.html":{"url":"install/install.html","title":"安装","keywords":"","body":"安装 Winodws安装 windows安装很简单，下载了安装包直接按提示一步一步安装即可，这里不再介绍。安装完成后，请将Python安装路径以及Scripts目录配置到环境变量中。 另外介绍下Anaconda安装，在Anaconda网站下载Windows下对应的Python3版本，进行标准安装即可。 Anaconda安装完成后，python的环境就配置好了。 Linux安装 由于我只安装了Ubuntu的虚拟环境，所以只介绍Ubuntu下安装Python。 其实安装完Ubuntu 18.04以后，系统就以及安装好了python2.7以及python3.6，如果需要源码安装Python3.7.3，则请参考我另外的文档：Ubuntu 中安装与配置 Python3.7 Linux下也支持Anaconda，可在Anaconda网站下载Linux下对应的Python3版本，按提示安装既可以。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"install/venv.html":{"url":"install/venv.html","title":"虚拟环境","keywords":"","body":"虚拟环境 什么是Python的虚拟环境呢？其实Python虚拟环境就是为项目创建的相对独立的开发环境，也就是可为每个项目安装各自独立使用的依赖模块。 解释了可能还是不明白，我最初也是不明白的，到底我只是学习python，搞那么多环境干啥呢？这里在举例解释下，比如你有2个python项目，同时都用到了某个第三方模块numpy，如果这2个项目使用同一个版本的numpy模块，那么不可能产生疑问。但如果使用了不同版本的numpy模块呢？由于python导入模块时并不能区分模块的版本，那么这2个使用不同版本numpy模块的项目就会出现问题了。 那怎么使用虚拟环境呢？在Python3中，默认安装了pyvenv。直接使用就可以了。 创建一个虚拟环境: $python3 -m venv pyvenv2 其中pyvenv2是虚拟环境建立的路径，可根据需求自行定义，该命令会自动在当前目录下建立目录，并将python环境copy到这个目录，该目录结构为： 图：1554967797901 要激活刚才创建的虚拟环境pyvenv2，那么只需要输入如下代码： $source pyvenv2/bin/activate 成功后，则提示符前会加入环境名称，如下： (pyvenv2) $ 如果要退出虚拟环境，那么直接输入： (pyvenv2) $deactivate 好了，验证下虚拟环境。在Python非虚拟环境下，输入命令： $which python /usr/bin/python 激活虚拟环境pyvenv2后，再次查看python路径： $source pyvenv2/bin/activate （pyvenv2）$which python /home/dastone/pyvenv2/bin/python 如果我们查看下环境变量$PATH，会发现这个变量在激活前后是不同的。 我们也可在python中查看环境变量以及pip的site packages目录： 图：1554970396705 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/":{"url":"basic/","title":"基础","keywords":"","body":"基础 在Python中，要了解class以及instance。所有的变量都有自己的class，一旦赋值以后就实例化(instance)了。每个变量都是自己的唯一ID值。 >>>id(123) 140734734037456 >>>id('abc') 2390831392056 不同Python实现使用了不同算法，CPython用内存地址作为ID值。所以ID不适合为全局身份标识，因为内存地址有可能会被重复使用。比如： >>> a = 123 >>>id(a) 140734734037456 #和上面id(123)的地址是一致的 >>>c=a >>>id(c) 140734734037456 可用type返回实例所属类型。比如： >>>type(123) >>>type(1.23) >>>type(True) >>>type(\"hello\") 要判断实例是否属于某个类型，可使用isinstance函数，比如： >>>isinstance(123,int) True >>>isinstance(1.23, float) True 注意，所有类型都属于类型object。object是所有类型的基类，提供了一些基本属性及操作方法等，所有类型都继承自object。但所有类型都是有type创建的，这和继承无关，如： >>>issubclass(int, object) True >>>id(int) 140734733558240 >>>type(int) >>>isinstance(int, type) True >>>issubclass(type,object) True 类型对象属于创建者这样特殊存在。默认情况下，它们在解释器首次载入时自动生成，生命周期与进程相同，且仅有一个实例。 变量 变量是具有特别格式的内存，而变量名则为内存别名，变量名与指针是不同的。Python是一种动态类型语言，也就是只有在运行时才知道变量名的类型。所以变量名必须和目标对象关联才可以，而最直接关联就是赋值，而后对变量名引用都解释为对目标对象的操作。 名字空间(namespace)是上下文环境中专门用来存储名字和目标引用关联的容器。在Python中，每个模块都有一个全局名字空间。而根据作用域，又会有当前名字空间或本地名字空间。内存函数globals和locals分别返回全局名字空间和本地名字空间字典。globals一般固定指向模块名字空间，而locals则指向当前作用域空间。 了解了名字空间，就知道变量名只是字符串主键，自身的数据结构中并没有任何目标对象信息。通过变量名访问目标对象，就是以名字为主键去空间字典中读取目标对象指针引用。所以，变量名可重新关联另一对象，而不在乎其类型是否与以前相同。 >>>x=100 >>id(x) 140705733701360 >>>globals() {...,'x':100} >>>x=\"abc\" #重新关联其他对象，没有类型限制 >>>id(x) #通过输出id，可看出关联新对象，而非修改原对象内容 1843192063288 >>>globals() #名字空间里引用发生了变更 {...,'x':'abc'} >>>locals() #模块作用域中，可通过id查看，globals与locals相同 {...,'x':'abc'} 赋值操作只是变量名在名字空间里重新关联，而非修改对象。单个对象可以同时又多个变量名。可用is来判断2个变量名是否引用同一对象。相等操作符会判断值是否相同。 >>>a = 2345 #请使用大数字，小数字常量会被缓存 >>>b = a >>>a is b True >>>c = 2345 >>>a is c False >>>a == c True >>>globals() #2345会有不同变量名 {...,'a':'2345','b':'2345','c':'2345'} 变量命名规则： 以字母或下划线开头 区分大小写 不能使用保留关键字 为统一风格，建议： 类型名称使用CapWords格式。 模块文件名、函数、方法成员等使用lower_case_with_underscores格式。 全局变量使用UPPER_CASE_WITH_UNDERSCORES格式 避免与内置函数或标准库常用类型同名。 如要检查代码是否违反保留字规则，可使用keyword模块。 >>>import keyword >>>keyword.kwlist ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] >>>keyword.iskeyword(\"yield\") True 注意：以下划线开头名字，代表特殊含义。 模块成员以单下划线开头(_x)，属于私有成员，不会被星号导入。 类型成员以双下划线开头，但无结尾(__x)，属自动重命名私有成员。 以双划线开头和结尾(__x__)，通常是系统成员，应避免使用。 在交互模式下，单下划(_)返回最后一个表达式结果。 内存 Python每个对象，即使是简单数字，在内存中也有标准对象头及保存类型指针和引用计数等信息。如果是字符串、列表等变长类型，还要记录数据项长度及状态数据。 内存总是按变量名来完成“引用传递”。变量名关联会增加计数，反之减少计数。如删除全部名字关联，那么该对象引用计数归零，会被系统回收。 >>>a=1234 >>>import sys >>>sys.getsizeof(a) 28 >>>b=a >>>sys.getrefcount(a) >>>3 >>>del a >>>sys.getrefcount(b) 2 所有对象都有内存管理系统在特定区域统一分配，无论赋值，传参还是返回局部变量都无需关心内存位置，并没有逃逸或隐式复制行为发生。 >>>def test(): x=\"Hello,test\" print(id(x)) return x #返回局部变量 >>>a=test() #对比id结果，确认局部变量被导出 1843195211120 >>>id(a) 1843195211120 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/data_type.html":{"url":"basic/data_type.html","title":"数据类型","keywords":"","body":"数据类型 Python内置的基本数据类型可简单分为数字、序列、映射和集合基类。又根据其实例是否可修改，分可变和不可变。 名称 分类 可变类型 int number N float number N str sequence N bytes sequence N bytearray sequence Y list sequence Y tuple sequence N dict mapping Y set set Y frozenset set N 标准库collections.abc可列出相关类型的抽象基类，及是否可变。 >>>import collections.abc >>>issubclass(str,collections.abc.Sequence) True >>>issubclass(str,collections.abc.MutableSequence) False 本部分有关列表、元组、字典等另开章节来讨论，本部分仅介绍字符串、数字、字节数组等。 字符串 字符串就是一系列字符，可用引号括起来的都是字符串，存储Unicode文本，是不可变序列类型。 >>>s = \"中国\" >>>len(s) 2 >>>hex(ord(\"中\")) '0x4e2d' >>>chr(0x4e2d) '中' >>>ascii(“中国”) \"'\\\\u4e2d\\\\u56fd'\" >>>\"h\\x69, \\u6c49\\U00005B57\" #\\u表示16位unicode，\\U为32位 'hi, 汉字' 引号可以为单引号，双引号。可灵活的使用单引号与双引号。如果字符串包含有单双引号，可使用转义符(\\)。当然，转义符也可以用来转义其他字符，比如制表符\\t,换行符\\n，但如果要使用\\，则需要使用\\\\来表示！ 比如： \"this is a string\" 'this is also a string' 'hello, \"python\"！' \"i'm a good boy!\" 'I\\'m \\\"OK\\\"' '\\tI love python!\\n\\n \\\\but python don\\'t easy!' 如果字符串有很多的\\ ,为了简化，可以使用r''来表示''内部字符串不转义，如 >>>print('\\\\\\t\\\\') #\\ \\ >>>print(r'\\\\\\t\\\\') #\\\\\\t\\\\ 如果有太多的换行\\n，或者每行的字符太长有多行时，可使用'''...'''来输入多行内容，比如： >>>print('''line1 ...line2 ...line3''') line1 line2 line3 字符串操作 操作 说明 示例 title 将字符串首字符大写 \"hello world\".title()=>Hello World lower 将字符串改为小写 \"Hello World\".lower()=>hello world upper 将字符串改为大写 \"hello world\".upper()=>HELLO WORLD rstrip 删除字符串右侧的空格 \" Python \".rstrip()=>' Python' lstrip 删除字符串左侧的空格 \" Python \".lstrip()=>'Python ' strip 删除字符串2侧的空格 \" Python \".strip()=>'Python' 字符串合并 字符串可使用+来拼接，比如： >>>s = \"Hello\" >>>s = s + ' '+'World' >>>print(s) 字符串合并也可混合运算符，比如+为合并，*为重复 >>>3*'un'+'ium' 'unununium' 2个或多个字符串会自动合并，如: >>>'Hello' ' ' 'Py' 'thon' Hello Python 多个动态字符串拼接，优先选择join或format方式。 >>>tmpl = \"/data/{user}/message/{time}.txt\" >>>tmpl.format(user=\"qyuhen\",time=\"2017010\") '/data/qyuhen/message/2017010.txt' >>>import string >>>x = list(string.ascii_uppercase) >>>\"\".join(x) #join比以+来拼接的性能要好的多 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 其他 要输入多行怎么办呢？可使用（）来输入多行，如： >>> text = ('Put several strings within parentheses ... 'to have them joined together.') >>> text 'Put several strings within parentheses to have them joined together.' 字符串其实就是一个元组，可使用元组的一些特性，如： >>>word='Python' >>>word[0] 'P' >>>word[-1] 'n' >>>word[0:2] #切片 'Py' >>>word[-2:] 'on' >>>J+word[1:] 'Jython' >>>s=\"-\"*1024 >>>s1=s[10:100] #片段 >>>s2=s[:] #复制，内容同 >>>s3=s.split(\",\")[0] #分割，内容同 使用in、not in 判断是否包含子串 >>>\"py\" not in \"Python\" True 内置函数len()表示字符串的长度 >>>S='abdde' >>>len(S) 5 转换 除了与数值、unicode转换外，还有不同编码之间转换。Python3使用bytes、bytearray存储字节序列。如要处理BOM信息，需导入codecs模块。 >>>str(1.23e10) '12300000000.0' >>>s=\"汉字\" >>>b=s.encode(\"utf-8\") >>>print(b) b'\\xe6\\xb1\\x89\\xe5\\xad\\x97' >>>b.decode(\"utf-8\") '汉字' >>>import codecs >>>codecs.BOM_UTF16_LE.hex() 'fffe' >>>codecs.encode(s,\"utf-16be\").hex() #按指定BOM转换 '6c495b57' >>>codecs.encode(s,\"utf-16le\").hex() '496c575b' >>>import sys >>>sys.getdefaultencoding() 'utf-8' 格式化 f-strings的支持，使用f前缀标志，解释器解析大括号内的字段或表达式，在上下文名字空间查找同名对象进行替换。格式化遵循format规范。 >>>x = 10 >>>y = 20 >>>f\"{x}+{y} = {x=y}\" #f-strings '10+20=30' >>>\"{}+{}={}\".format(x,y,x+y) #str.format '10+20=30' >>>f\"{type(x)}\" #函数调用 \"\" 完整的format格式化以位置序号或字段名匹配参数进行替换，可添加对齐、填充、精度等控制。从某种角度看，f-strings类似format的增强语法糖。 手工序号和自动序号 >>>\"{0} {1} {0}\".format(\"a\", 10) 'a 10 a' >>>\"{} {}\".format(1, 2) #自动序号 '1 2' 主键 >>>\"{x} {y}\".format(x =100, y= [1, 2, 3]) '100 [1, 2, 3]' 属性和索引 >>>x.name = \"jack\" >>>\"{0.name}\".format(x) #对象属性 'jack' >>>\"{0[2]}\".format([1,2,3,4]) #索引 '3' 宽度、补位 >>>\"{0:#08b}\".format(5) '0b000101' 数字 >>>\"{:06.2f}\".format(1.234) '001.23' 对齐 >>>\"[{:^10}]\".format(\"abc\") #居中 '[ abc ]' >>>\"[{:. 池化 字符串是进程实例数量对多的类型之一，为节约内存，且可省去创建新实例开销，可对内容相同，且不可变的变量名进行池化。在Python中就是实现一个字符串池（intern)，这样好处就是池负责管理实例，只需引用即可使用；从池中返回字符串，只需比较指针就可知内容是否相同，以提高性能。但一旦失去外部引用，池内字符串对象可能会被回收 >>>a=\"abc\" >>>b=\"abc\" >>>a is b False >>>sys.intern(a) is sys.intern(\"abc\") True >>>a = sys.intern(\"hello,world!\") >>>id(a) 2811852698032 >>>id(sys.intern(\"hello,world!\")) 2811852698032 >>>del a #删除外部引用后被回收 >>>id(sys.intern(\"hello,world!\")) #从id值不同可看到是新建后入池的 2811852698224 数字 整数 在Python3中，将int、long这两种类型合并为int,采用变长结构。可处理任意大小整数，并可使用加(+)减(-)乘(*)除-(/)来运算。可以用python当计算器做各种运算。 >>> 3*3 9 >>>3**3 27 >>>3/2 #单斜线为True Division，无论是否整除，总返回浮点数 1.5 >>>3 // 2 #双斜线为False Division，会截掉小数部分，仅返回整数结果 1 >>>(2+10)*2-(10+3) 11 >>>78_654_321 #由于逗号表示tuple语法，可使用下划线便是分割千位位数 78654321 >>>5%2 #取模运算符(mod) 1 >>>divmod(99,5) (19,4) 除了十进制，还可以二进制、八进制、十六进制表示。下划线分隔符号也适用这些进制的字面量。 >>>0b110011 #bin 51 >>>0o12 #oct 10 >>>0x64 #hex 100 >>>0b_11001_1 51 可用内置函数将整数转换为指定进制字符串，或使用int还原，int函数默认为十进制，会忽略空格、制表符等，如指定进制，则可省略相关进制前缀。 >>>int(\"0b1100100\",2) 100 >>>int(\"0o144\",8) 100 >>>int(\"0x64\",16) 100 >>>int(\"64\",16) 100 >>>int(\" 100\\t \") 100 如使用eval也可完成转换，但性能要差很多。 将整数转换为字节数组时需要指定目标字节数组大小，而整数类型是变长结构，故通过二进制位长度来计算，另可通过sys.byteorder来获取当前系统字节序。 >>>x=0x1234 >>>n=(x.bit_length()+8-1)//8 #计算按8位对齐所需的字节数 >>>b=x.to_bytes(n,sys.byteorder) >>>b.hex() '3412' >>>hex(int.from_bytes(b,sys.byteorder)) '0x1234' 布尔 布尔为整数子类型。True，False可当做整数直接使用。 >>>True == 1 True >>> False == 0 True >>>issubclass(bool,int) True >>>isinstance(True,int) True >>>True+1 2 在进行布尔转换时，数字零、空值(None)、空序列和空字典都为False，反之为True。 >>>data=(0,0.0,None,\"\",list(),tuple(),dict(),set(),frozenset()) >>>any(map(bool,data)) False 枚举 Python中没有枚举类型的定义，但可通过标准库来实现。首先定义枚举类型，随后由内部代码生成枚举值实例。 >>>import enum >>>Color = enum.Enum(\"Color\",\"BLACK YELLOW BLUE RED\") >>>isinstance(Color.BLACK, Color) True >>>list(Color) [, , , ] 枚举值不一定为整数，可通过继承，将其指定为任一类型。 >>>class X(enum.Enum): A=\"a\" B=100 C=[1,2,3] >>>X.C 枚举类型的内部以字典方式实现，每个枚举值都有name和value属性。可通过名字或值查找对应枚举实例。按字典规则，值可相同，但名字不可重复。如要避免相同枚举定义，可用enum.unique装饰器。 >>>X.B.name 'B' >>>X.B.value 100 >>>X[\"B\"] >>>X([1,2,3]) 内存 在Python中，小数字都会预先缓存，一般缓存范围为[-5,256]。如超出这个范围，则要新建对象，并内存分配等。 >>>a=-5 >>>b=-5 >>>a is b True >>>a=257 >>>b=257 >>>a is b False 浮点数 带小数的就是浮点数，可表达16到17个小数位。浮点数的小数点位置是可以变的。比如$1.2310^9$和$12.310^8$是相等的。浮点数可使用数学写法，如:1.23，3.14，-9.01，但也可使用科学计数法，如$1.23*10^9$就是1.23e9，0.000012可写成1.2e-5，等等。 >>>tax=12.5/100 >>>price=100.50 >>>price*tax 12.5625 >>>price+_ 113.0625 >>>round(_,2) 113.06 >>>0.1234567890123456789 0.12345678901234568 在交互模式下，变量(_)代表了最后一个表达式。 如对精度有严格要求，则应该固定精度类型。可通过float.hex方法输出实际存储值的十六进制格式字符串。也可通过该方法实现浮点值精度传递，避免精度丢失。 >>>0.1*3 == 0.3 False >>>(0.1*3).hex() '0x1.3333333333334p-2' >>>(0.3).hex() '0x1.3333333333333p-2' >>>s=(1/3).hex() >>>float.fromhex(s) 0.3333333333333333 可固定精度情况下进行比较操作，比如： >>>round(0.1*3, 2)==round(0.3, 2) #避免不确定性，左右都使用固定精度 True >>>round(0.1, 2)*3 == round(0.3, 2) #round返回值作为操作数会导致精度丢失 False 转换 将整数或字符串转换成浮点数很简单，使用内置float函数即可。如超出了有效精度，结果会有差异。 >>>float(\"\\t 100.123\\n \") #会自动处理空白符 100.123 >>>float(\"1.234E2\") #科学计数 123.4 >>>float(\"0.1234567890123456789\") 0.12345678901234568 如浮点数转为整数，可使用内置函数int或标准库函数trunc,floor,ceil等 >>>int(2.6),int(-2.6) (2,-2) >>>from math import trunc,floor,ceil >>>trunc(2.6),trunc(-2.6) #截取小数部分 (2,-2) >>>floor(2.6),floor(-2.6) #往小数字方向去最近整数 (2, -3) >>>ceil(2.6),ceil(-2.6) #往大数字方向取最近整数 (3, -2) >>>round(2.6),round(-2.6) #四舍五入 （3， -3） decimal.Decimal可提供最高28位有效精度，而且不存在近似值问题。 >>>1.1+2.2 3.3000000000000003 >>>from decimal import Decimal >>>Decimal(\"1.1\")+Decimal(\"2.2\") Decimal('3.3') >>>Decimal(0.1) #必须传入准确数值，比如整数或字符，如传入float则精度会丢失 Decimal('0.1000000000000000055511151231257827021181583404541015625') 除非有需求，不建议用Decimal替代float，这样的性能会差很多。可使用getcontext或localcontext来修改Decimal默认的28位精度。 >>>from decimal import Decimal,getcontext,localcontext >>>getcontext() Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[FloatOperation], traps=[InvalidOperation, DivisionByZero, Overflow]) >>>getcontext().prec = 2 #根据上下文修改全局的精度 >>>Decimal(1) / Decimal(3) Decimal('0.33') >>> with localcontext() as ctx: #localcontext限制某个区域精度 ctx.prec =3 print(getcontext().prec) print(Decimal(1)/ Decimal(3)) 3 0.333 四舍五入 因为近似值和精度问题，使用float进行四舍五入会出现操作的不确定性。 >>>round(0.5) 0 >>>round(1.5) 2 由于不确定，可改用Decimal，按需求选取可控的进位。 >>>from decimal import Decimal, ROUND_HALF_UP >>>def roundx(x,n): return Decimal(x).quantize(Decimal(n),ROUND_HALF_UP) >>>roundx(\"0.5\",1) Decimal('1') >>>roundx(\"2.675\",\".01\") Decimal('2.68') 字节数组 从底层实现来看，所有数据都是二进制字节序列，在Python2引入了bytearray字节数组，在Python3新增了只读版本的bytes。字节数组为不可变序列类型。bytes与str有类似的操作。和bytes一次性内存分配相比，bytearray可按需扩张，同样也支持加法、乘法等运算符。 >>>b\"abc\" b'abc' >>>bytes(\"汉字\",\"utf-8\") b'\\xe6\\xb1\\x89\\xe5\\xad\\x97' >>>a=b\"abc\"+b\"def\" >>>a b'abcdef' >>>a.startswith(b\"abc\") True >>>a.upper() b'ABCDEF' >>>b=bytearray(b\"ab\") >>>len(b) 2 >>>b.append(ord(\"c\")) >>>b.extend(b\"de\") >>>b bytearray(b'abcde') >>>b=b+b\"123\"+b\"78\"*3 >>>b bytearray(b'abcde123787878') 内存视图 Python没有指针的概念，另有内存安全模型的限制。要借助名为内存视图的方式来访问底层内存数据。内存视图要求目标对象支持缓冲协议。它直接引用目标内存，没有额外复制行为。因此，可读取最新数据。在目标对象允许下，还可执行写操作。常见支持视图操作的有bytes、bytearray、array.array及NumPy的某些类型。 >>>a = bytearray([0x10,0x11,0x12,0x13,0x14,0x15,0x16]) >>>v = memoryview(a) #完整视图 >>>x = v[2:5] #视图片段 >>>x.hex() '121314' >>>a[3]=0xee #修改原数据，可通过视图观察到 >>>x.hex() '12ee14' >>>x[1]=0x13 #因引用相同内存区域，可通过视图修改原数据 >>>a bytearray(b'\\x10\\x11\\x12\\x13\\x14\\x15\\x16') 视图片段有自己索引范围，注意不要超出限制。是否可通过视图修改数据，需要看原对象是否允许。不如bytes就不可修改。 >>>a = b\"\\x10\\x11\" >>>v = memoryview(a) >>>v[1] =0xEE Traceback (most recent call last): File \"\", line 1, in TypeError: cannot modify read-only memory 如果复制视图数据，可用tobytes、tolist等方法。复制后与原对象无关，不会影响视图本身。 >>>a = bytearray([0x10,0x11,0x12,0x13,0x14,0x15,0x16]) >>>v = memoryview(a) #完整视图 >>>x = v[2:5] #视图片段 >>>b = x.tobytes() #复制并返回视图数据 >>>b b'\\x12\\x13\\x14' >>> a[3]=0xff #不影响复制数据 >>>b b'\\x12\\x13\\x14' © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/list.html":{"url":"basic/list.html","title":"列表","keywords":"","body":"列表 Python内置的列表list是一种有序集合，可随时添加或删除其中元素，可当做队列或栈来使用。用方括号([])来表示列表。如： >>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana'] 如要定义一个空列表，则如下： >>> empty_list = [] >>> empty_list [] >>> len(empty_list) 0 列表内部结构由两部分组成，保存元素数量和内存分配计数的头部，以及存储元素指针的独立数据。所有元素项使用该数组保存指针引用，并不嵌入实际内容。 不同于数组，列表仅存储指针，而对元素内容不关心，故可用不同类型混合。 >>>l=[1,\"abc\",3.14] >>>list(\"abc\") ['a', 'b', 'c'] >>>[x**2 for x in range(3)] [0, 1, 4] >>>[x for x in range(10) if x%2 ==0] #for循环初始数据，if表达式过滤 [0, 2, 4, 6, 8] 列表基本操作 访问列表 列表第一个元素为0，要访问列表只需如数组般访问即可，如： >>>print(fruits[0]) orange 要访问最后一个元素，可指定索引为-1，如: >>>print(fruits[-1]) banana 可对访问的值进行操作，比如： >>>print(fruits[-2].title()) Apple 可使用len来获取列表的长度，如 >>>len(fruits) 7 判断元素是否存在，使用in，而非index方法。 >>>2 in [1,2] True 修改、添加元素 修改列表的元素值很简单，直接将访问的值进行修改就可以了，如： >>>fruits[0] = 'grape' >>>print(fruits) ['grape', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana'] 添加元素，可使用append，如 fruits.append('abc') 这样就将元素添加到了列表的最后。而其他元素并没有受到影响。 插入元素到指定位置，使用insert,如 fruits.insert(1,'abc') 将元素添加到了指定位置，该位置以前元素没有任何影响，该位置以后的索引右移了一位。 也可使用加法或乘法进行添加元素。 >>>a=[1,2] >>>b=a >>>a=a+[3,4] #新建列表对象，然后与a关联 >>>a #a,b结果不同，a指向了新对象 [1,2,3,4] >>>b [1,2] >>>a=[1,2] >>>b=a >>>a +=[3,4] #直接修改a内容 >>>a #a,b结果相同，确认修改原对象 [1,2,3,4] >>>b [1,2,3,4] >>>a is b True “+=”运算符编译器处理为INPLACE_ADD操作，也就是修改原数据，而非创建新对象。效果类似list.extend方法。 删除元素 使用del语句删除元素,比如： del fruits[1] del可删除任何位置的列表元素，但必须有索引。 del也可以删除整个列表，注意删除后列表则不可访问了。 >>>del fruits >>print(fruits) Traceback (most recent call last): File \"\", line 1, in NameError: name 'fruits' is not defined 使用pop()来删除元素，比如： poped_fruits = fruits.pop() pop删除元素后会返回删除的元素。而且pop一定是删除最后一个元素。如果要pop指定位置元素，则比如传入索引，比如： fruits.pop(2) 那么，到底是该使用del语句还是pop()方法了，一个简单判断标准就是：如从列表中删除一个元素，且不再使用它了，就是用del语句；如删除元素后还要继续使用它，则使用方法pop()。 remove删除元素，如果知道要删除元素的值，但不知道位置，则使用remove了。比如： fruits.remove('abc') remove只删除第一个指定的值，如要删除的值在列表中多次出现，则需要使用循环判断来删除了。 列表排序 永久排序 使用方法sort()进行永久排序，比如定义一个列表及排序: >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>cars.sort() >>>print(cars) ['audi', 'bmw','subaru','toyota'] 如要反排序，则使用方法sort()时传入参数reverse=True,如下： >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>cars.sort(reverse=True) >>>print(cars) ['toyota','subaru','bmw','audi'] 临时排序 使用sorted()对列表临时排序，如： >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>print(sorted(cars)) ['audi', 'bmw','subaru','toyota'] >>>print(cars) ['bmw', 'audi', 'toyota', 'subaru'] 同样，可使用reverse=True来进行反排序。 有序列表插入元素 可利用bisect模块，要有序列表插入元素。它使用二分法查找适合位置，可用来实现优先对列或一致性哈希算法。 >>>d=[0,2,4] >>>bisect.insort_left(d,1) #插入新元素后，依然保持有序状态 >>>d [0, 1, 2, 4] 对于自定义符合类型，可通过重载比较运算符(__eq__、__lt__)等实现自定义排序条件。 按设定条件排序 >>>class User: def __init__(self,name,age): self.name = name self.age = age def __repr__(self): return f\"{self.name} {self.age}\" >>>users = [User(f\"user{i}\", i) for i in (3,1,0,2)] >>> users [user3 3, user1 1, user0 0, user2 2] >>>users.sort(key=lambda u:u.age) #使用lambda匿名函数返回排序条件 >>> users [user0 0, user1 1, user2 2, user3 3] 顺序与长度 列表也可以使用reverse()进行修改顺序，调用后会永久修改列表元素的排列顺序，如要恢复，则再次调用。 >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>cars.reverse() >>>print(cars) ['subaru','toyota','audi','bmw'] 列表的长度使用len,如： >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>len(cars) 4 请注意列表的索引，如超出这个范围则会错误，如列表的长度为n,则序号为[-n...n-1]之间。如超出，则会出现如下错误： Traceback (most recent call last): File \"\", line 1, in IndexError: list index out of range 遍历列表 要访问列表的所有元素，可使用for循环。 cars = ['bmw', 'audi', 'toyota', 'subaru'] for car in cars: print(car) 创建列表 使用函数range() 可使用range()来生成一系列数字，如 for value in range(1,5) print(value) range(1,5)会打印数字1-4，range()有3个参数，开始数字，结束数字以及步长，如range(1,10,3)则会打印1,4,7这3个数。 如要生成数字列表，可如下： >>>nums = list(range(1,6)) >>>print(nums) [1,2,3,4,5] 数字列表的简单统计 可使用min,max,sum来对数字列表进行统计。 >>>digits = list(range(1,10)) >>>min(digits) 1 >>>max(digits) 9 >>>sum(digits) 45 列表解析 列表解析就是将for循环以及创建新元素代码合并成一行，病自动附件新元素。如 >>>squares = [values**2 for value in range(1,11)] >>>print(squares) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 列表切片 如果访问列表部分元素，可使用切片，一般要指定第一个元素及最后一个元素的索引，和range()函数差不多吧。如： >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>print(cars[0:3]) ['bmw', 'audi', 'toyota'] 如没有指定第一个索引，则从列表开头开始，如没有指定第二个索引，则到列表结尾结束;当然，索引也可以是负数，如: cars[:3] #等同cars[0:3] 复制后依然指向同一个对象 cars[2:] #等同cars[2:4] cars[:] #等同cars或cars[0:4] cars[-3:] #等同cars[-3,0],打印最后3个 当然切边后的列表也是列表，所以还是可以遍历的，可试下？ 复制列表 复制列表，可使用切片方法来复制。如 cars = ['bmw', 'audi', 'toyota', 'subaru'] new_cars = cars[:] 为啥不直接赋值呢？比如new_cars=cars不行么？好像是可以，但还是有问题。赋值后指向同一个地址，当修改一个列表，则另一个列表也修改了，这是你所预期的？ 返回切片时创建新列表对象，并复制相关指针数据到新数组。除所引用目标相同外，对列表本身的修改(插入、删除等)并不影响。 注意复制的时指针（引用），而非目标元素对象。对列表自身的修改互不影响，但对目标元素对象的修改是共享的。 >>>a=[0,2,4,6] >>>b=a[:2] >>>a[0] is b[0] #复制引用，依然指向同一对象 True >>>a.insert(1,1) #对a列表操作，不影响b >>>a [0,1,2,4,6] >>>b [0,2] 元组 列表是可变的数据集，那么元组呢？元组就是不可变的数据集。元组一旦修改，则不可改变。元组和列表类似，元组是使用圆括号来标识的。定义元组后，可如列表一样进行访问，遍历等，但不可以修改，删除。 因元组为不可变类型，它的指针数组无需变动，故一次性完成内存分配。系统会缓存复用一定长度的元组内存(含指针数组)。元组性能要优于列表。 定义元组 元组定义很列表类似，如： dimensions = (200,500) 如果要定义一个空元组，可如下定义： empty = () 那定义一个有一个元素的元组呢？ >>>t = (1) >>>print(t) 1 怎么打印出来不是元组，是个数字1呢？这是因为()既可以标识元组，也可以表示数学中的小括号，为了消除歧义，必须加一个逗号，，如下定义一个元素的元组： >>>t=(1,) >>>print(t) (1,) >>>type(t) >>>b=(1) >>>type(b) 支持与列表类似运算符操作。但不能修改，总返回新对象， >>> (1,2)+(3,) (1, 2, 3) >>> (1,2)*2 (1, 2, 1, 2) >>> a=(1,2,3) >>> b=a >>> a+=(4,5) #与列表不同，创建新tuple，而不是修改原内容。等同a=a+(4,5) >>> a (1, 2, 3, 4, 5) >>> b (1, 2, 3) 因列表可变，故序号无法与元素对象构成固定映射。但元组不同，相同序号总是同一个对象。故可为序号取“别名”。 >>> User = collections.namedtuple(\"User\",\"name, age\") #创建并指定字段 >>> issubclass(User,tuple) #tuple子类 True >>> u=User(\"qyuhen\",60) >>> u.name,u.age #使用字段名访问 ('qyuhen', 60) >>> u[0] is u.name #序号与“别名”相同 True 数组 数组和列表、元组的本质区别在于：元素单一类型和内容嵌入。 >>> import array >>> a= array.array(\"b\",[0x11,0x22,0x33,0x44]) >>> memoryview(a).hex() '11223344' >>> a=array.array(\"i\") >>> a.append(100) >>> a.append(1.23) Traceback (most recent call last): File \"\", line 1, in TypeError: integer argument expected, got float 可直接存储包括Unicode字符在内的各种数字。如要复合类型，则需用struct,marsha1,pickle等转换二进制字节后再行存储。 与列表类似，数组长度不固定，可按需扩张或收缩内存。 >>> a=array.array(\"i\",[1,2,3]) >>> a.buffer_info() #返回缓冲区内存地址及长度 (2811820040688, 3) >>> a.extend(range(10000)) #追加大量内容后，内存地址和长度变化了。 >>> a.buffer_info() (2811851399072, 10003) 由于可指定数字类型，故数组可节约内存。内容嵌入也避免了对象额外开销，减少了活跃对象数量和内存分配次数。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/dict.html":{"url":"basic/dict.html","title":"字典","keywords":"","body":"字典 字典为内置类型中唯一的映射结构，基于哈希表存储键值对数据。字典与列表和元组不同，存储的信息会更多，更准确。字典使用花括号({})来表示，使用一系列的键-值，可使用键来访问对应的值。值可以是任意数据，但主键必须可哈希类型，故列表、集合等都不可以作为主键使用。 >>> issubclass(list,collections.Hashable) False >>> issubclass(int,collections.Hashable) True >>> issubclass(tuple,collections.Hashable) True 元组为不可变类型，但如引用了可变类型元素，则不能为主键，比如tuple引用了dict,set,list中任意一种则不可为主键。 >>> hash((1,2,3)) 2528502973977326415 >>> hash((1,2,[3,4])) Traceback (most recent call last): File \"\", line 1, in TypeError: unhashable type: 'list' 创建字典，比如: product = {'color': 'red', 'price': 51.00} print(product[color]) print(product[price]) >>>dict(a=1, b=2) {'a': 1, 'b': 2} 初始化键值参数可以元组、列表等可迭代对象方式提供。 >>> kvs=((\"a\",1),[\"b\",2]) >>> dict(kvs) {'a': 1, 'b': 2} 基于动态数据创建，多用zip、map函数或推导式完成。 >>> dict(zip(\"abc\",range(3))) {'a': 0, 'b': 1, 'c': 2} >>> dict(map(lambda k,v:(k, v+10),\"abc\",range(3))) {'a': 10, 'b': 11, 'c': 12} >>> {k: v+10 for k, v in zip(\"abc\", range(3))} #推导式处理数据 {'a': 10, 'b': 11, 'c': 12} 基于已有字典内容扩展或者初始化零值等。 >>> a = {\"a\": 1} >>> b = dict(a, b=1) # 在复制 a 内容的基础上，新增键值对 >>> b {'a': 1, 'b': 1} >>> c = dict.fromkeys(b, 0) # 仅用 b 的主键，内容另设 >>> c {'a': 0, 'b': 0} >>> d = dict.fromkeys((\"counter1\", \"counter2\"), 0) # 显示提供主键 >>> d {'counter1': 0, 'counter2': 0} 添加、修改、删除键值 字典是动态的，可随时添加键值以及修改、删除键值。如： product = {'color': 'red', 'price': 51.00} product['qty'] = 5 product['disc'] = -3 product[price] = 53 del product['disc'] 如主键不存在会出现异常，可先用in、not in语句判断，或用get方法返回默认值。 >>> x = dict(a=1) >>> x[\"b\"] Traceback (most recent call last): File \"\", line 1, in KeyError: 'b' >>> \"b\" in x False >>> x.get(\"b\",100) # 主键b不存在，返回默认值100 100 >>> x.get(\"a\",100) # 主键a存在，返回实际内容 方法get的默认参数仅返回，不影响字典内容。但如想字典插入默认值，则可使用setdefault。 >>> x = {} >>> x.setdefault(\"a\", 0) #如果有a,返回实际内容，否则新增{a:0}键值对 0 >>> x {'a': 0} >>> x[\"a\"] = 100 >>> x.setdefault(\"a\", 0) 100 字典不支持加法、乘法、大小等运算，但可比较内容是否相同。 >>> {\"a\": 1, \"b\": 2} == {\"a\": 1, \"b\": 2} True 遍历字典 如列表、元组一样，可遍历字典的所有键值。 product = {'color': 'red', 'price': 51.00} for key, value in product.items: print(\"Key:\"+key) print(\"\\nValue:\"+value) 字典的所有key实际组成了一个列表，你可如列表一样进行遍历： for key in product.keys(): print(\"Key:\"+key) 同样，所有的value也组成了列表，可通过product.values()访问。 既然字典的keys()、values()都是列表，那一样适用列表的属性，比如可使用sorted进行临时排序。 嵌套 字典内的元素不一定就是固定一种类型，其值可以是字符串，数字，布尔值，元组，列表，甚至字典。也就是字典中可嵌套列表或字典，同样，列表也可嵌套字典、列表等。 product1 = {'color':'red','price':53} product2 = {'color':'blue','price':44} products = [product1,product2] for product in products: print(product) pizza = { 'crust': 'thick', 'toppints': ['mushrooms', 'extra cheese'], } users = { 'john': { 'first': 'jack', 'last': 'zhao' }, 'rose': { 'first': 'rose', 'last': 'li' }, } 视图 Python3默认以视图关联字典内容，这样既可避免复制开销，又可同步观察字典变化。 >>> x = dict(a=1,b=2) >>> ks=x.keys() #主键视图 >>> \"b\" in ks #判断主键是否存在 True >>> for k in ks: print(k, x[k]) #利用视图迭代字典 ... a 1 b 2 >>> x[\"b\"]=200 #修改字典内容 >>> x[\"c\"]=3 #没有则新增 >>> for k in ks: print(k, x[k]) #视图同步变化 ... a 1 b 200 c 3 字典如直接引用则可能被接收方修改，如复制则无法获取字典变化。如使用视图，则可同步读取字典内容而无法修改。且可选择不同粒度内容进行传递，如此可将接收方限定为指定模式下的观察者。 >>> def test(d): #传递键值视图(items)，只能读取，不可修改 ... for k, v in d: ... print(k, v) ... >>> x=dict(a=1) >>> d=x.items() >>> test(d) a 1 视图还支持集合运算，以弥补字典功能上的不足。 >>> a = dict(a=1,b=2) >>> b = dict(c=3,b=2) >>> ka=a.keys() >>> kb=b.keys() >>> ka & kb #交集：在a、b中同时存在 {'b'} >>> ka | kb #并集：在a或b中存在 {'b', 'c', 'a'} >>> ka - kb #差集：仅在a中存在 {'a'} >>> ka ^ kb #对称差集：仅在a或仅在b中出现，等同“并集-交集” {'c', 'a'} 利用视图集合运算，可简化某些操作。如，只更新，不新增。 >>> a = dict(a=1, b=2) >>> b = dict(b=20, c=3) >>> ks = a.keys() & b.keys() # 交集，也就是a中必须存在的主键 >>> a.update({k:b[k] for k in ks}) >>> a {'a': 1, 'b': 20} 扩展 标准库collections的默认字典(defaultdict)类似setdefault包装。当主键不存在，调用构造参数提供的工厂函数返回默认值。 >>> d = collections.defaultdict(lambda: 100) >>> d[\"a\"] 100 >>> d[\"b\"] +=1 >>> d defaultdict( at 0x00000171FD7AA840>, {'a': 100, 'b': 101}) 有序字典(OrderedDict)会记录主键首次插入的次序。 >>> d = collections.OrderedDict() >>> d[\"z\"] =1 >>> d[\"a\"] =2 >>> d[\"x\"] =3 >>> for k, v in d.items(): print(k, v) z 1 a 2 x 3 与前面介绍不同，计算器(Counter)对不存在主键返回0，但不会新增。 >>> d = collections.Counter() >>> d[\"a\"] 0 >>> d[\"b\"]+=1 >>> d Counter({'b': 1}) 链式字典(ChainMap)以单一接口访问多个字典内容，其自身并不存储数据。读操作按参数顺序依次查找各字典，但修改操作(增、改、删)仅针对第一字典。 >>> a = dict(a=1, b=2) >>> b = dict(b=20, c=30) >>> x = collections.ChainMap(a, b) >>> x[\"b\"], x[\"c\"] #按顺序命中 (2, 30) >>> for k,v in x.items(): print(k, v) #遍历所有字典 ... b 2 c 30 a 1 >>> x[\"b\"] = 999 #更新，命中第一字典 >>> x[\"z\"] = 888 #新增，命中第一字典 >>> x ChainMap({'a': 1, 'b': 999, 'z': 888}, {'b': 20, 'c': 30}) 链式字典查找次序可被调用链的后续函数读取，这也是继承的体现。而修改操作限定在当前第一字典中，故不会影响父级字典的同名主键设置。 >>> root = collections.ChainMap({\"a\": 1}) >>> child = root.new_child({\"b\": 200}) >>> child[\"a\"] =100 >>> child ChainMap({'b': 200, 'a': 100}, {'a': 1}) >>> child.parents ChainMap({'a': 1}) 集合 集合存储非重复对象。这里的非重复是指不是同一对象外，值也不能相等。 判重公式：(a is b) OR (hash(a) == hash(b) AND a==b ) 如不是同一对象，则先判断哈希值，然后比较内容。受限哈希算法，不同内容可能返回相同哈希值(哈希碰撞)。为啥要先比较哈希值呢？首先，与内容相比，整数哈希值比较性能要高很多，其次，哈希值不同，内容肯定不同，则不需继续比较内容。 >>> a=1234 >>> b=1234 >>> a is b #内容同，但不是相同对象 False >>> s={a} #创建集合，初始化元素a >>> b in s #用内容相同的b进行判重 True 按操作方式，集合分可变(set)和不可变(frozenset)两种，内部实现相同。用数组实现的哈希表存储元素对象引用，这也就要求元素必须为可哈希类型。 创建 与字典语法相同，使用花括号，但初始化数据非键值对。 >>> type({}) # 没有初始化值，表示创建空字典 >>> type({\"a\":1}) #字典：键值对 >>> type({1}) #集合 >>> set({1, \"a\", 1.0}) {1, 'a'} >>> frozenset(range(3)) frozenset({0, 1, 2}) >>> {x+1 for x in range(6) if x%2 == 0 } //推导式创建 {1, 3, 5} >>> s = {1} >>> f = frozenset(s) # set与frozenset转换 >>> set(f) {1} 操作 支持大小、相等运算符。 >>> {1, 2} > {2, 1} False >>> {1, 2} == {2, 1} True 子集判断不可用in、not in语句，它仅用来检查是否包含某个元素。 >>> {1, 2} >> {1, 2, 3} >= {1, 2} # 超集：issuperset True >>> {1, 2} in {1, 2, 3} # 判断是否包含{1， 2}单一元素 False 集合作为初等数学概念，重点是并差集运算。 交集： 同时属于A、B两个集合。 并集：A、B的所有元素。 差集：仅属于A，不属于B。 对称差集：仅属于A，加上仅属于B，相当“并集 - 交集”。 >>> {1, 2, 3} & {2, 3, 4} #交集：intersection {2, 3} >>> {1, 2, 3} | {2, 3, 4} #并集：union {1, 2, 3, 4} >>> {1, 2, 3} - {2, 3, 4} #差集: difference {1} >>> {1, 2, 3} ^ {2, 3, 4} #对称差集：symmetric_difference {1, 4} 集合运算还可与更新操作一起使用。 >>> x = {1, 2} >>> x |= {2, 3} >>> x {1, 2, 3} >>> x = {1, 2} >>> x &= {2, 3} >>> x {2} 删除操作不能用remove，可能引发异常，可改用discard。 >>> x = {2, 1} >>> x.remove(2) >>> x.remove(2) Traceback (most recent call last): File \"\", line 1, in KeyError: 2 >>> x.discard(2) 自定义类型 自定义类型虽可是哈希类型，但默认实现并不足以完成集合去重操作。 >>> class User: ... def __init__(self,uid,name): ... self.uid=uid ... self.name=name >>> issubclass(User, collections.Hashable) True >>> u1 = User(1, \"user1\") >>> u2 = User(1, \"user1\") >>> s=set() >>> s.add(u1) >>> s.add(u2) >>> s {, } 根本原因是默认实现的__hash__方法返回随机值，而__eq__仅比较自身。为符合逻辑需求，需重载这2个方法。 >>> class User: ... def __init__(self, uid, name): ... self.uid =uid ... self.name=name ... def __hash__(self): #针对uid去重，忽略其他字段 ... return hash(self.uid) ... def __eq__(self, other): ... return self.uid == other.uid ... >>> u1 = User(1,\"user1\") >>> u2 = User(1,\"user1\") >>> s=set() >>> s.add(u1) >>> s.add(u2) >>> s {} >>> u1 in s True >>> u2 in s True © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/express.html":{"url":"basic/express.html","title":"表达式","keywords":"","body":"表达式 赋值 赋值操作就是为变量名与目标对象建立关联。 多个名字赋值： >>>a = b = c = 1023 >>> a is b is c True 以逗号分割多个值会当做元组的初始化元素。 >>> x = 1, \"abc\", {10, 20} >>> x (1, 'abc', {10, 20}) 增量赋值 增量赋值就是直接修改原对象内容，实现累加效果。前提是目标必须存在，而且目标对象允许，否则为普通赋值。也可以可变列表，不可变元组进行增量赋值。 >>> s = 0 >>> s += 10 >>> a = b = [] >>> a += [1,2] >>> a is b # 同一对象 True >>> c = d = () >>> c += (1, 2) >>> c is d # 新对象 False 可看出，列表直接修改原内容，而元组新建对象。按编译器处理是按INPLACEADD指令，但最终执行按时按目标类型定。这里的+=，对应\\_iadd__方法，如该方法不存在，则会执行__add__方法，这样就从增量操作变成了普通加法操作了。 >>> \"__iadd__\" in dir([1,2]) True >>> \"__iadd__\" in dir((1,2)) False >>> \"__add__\" in dir((1,2)) True 序列解包 与多个名字关联到一个对象不同，序列解包是展开所有元素，再分别于多个名字关联、 >>> a, b, c = [1, 2, 3] >>> a, b, c (1, 2, 3) >>> a, b, c = \"xyz\" >>> a, b, c ('x', 'y', 'z') >>> a, b, c = range(3) >>> a, b, c (0, 1, 2) >>> a, b = [1,2], (3,4) >>> a [1, 2] >>> b (3, 4) >>> a, b = b, a #交换对象 >>> a (3, 4) >>> b [1, 2] >>> a, ((b, c), (d, e)) = 1, [(10, 20), \"ab\"] #深度嵌套，左右值表达式以相同方式嵌套。 >>> a, b, c, d, e (1, 10, 20, 'a', 'b') >>> a, _, b, _, c = \"a0b0c\" #以_来忽略某些元素 >>> a, b, c ('a', 'b', 'c') >>> a, b = 1, 2, 3 #序列元素与变量名不等时解包错误 Traceback (most recent call last): File \"\", line 1, in ValueError: too many values to unpack (expected 2) >>> a, *b, c = range(5) #名字前添加星号*，表示可接纳所有多余元素 >>> a, b, c (0, [1, 2, 3], 4) >>> a, *b, c = 1, 2 #收集不到数据，返回空列表 >>> a, b, c (1, [], 2) >>> a, *b, c, d = 1, 2 # 元素少于非收集变量名数目 Traceback (most recent call last): File \"\", line 1, in ValueError: not enough values to unpack (expected at least 3, got 2) >>> a, *b, *c, d = range(10) # 不能出现2个或以上的星号 File \"\", line 1 SyntaxError: two starred expressions in assignment >>> *a = 1, 2 # 星号收集不能单独出现 File \"\", line 1 SyntaxError: starred assignment target must be in a list or tuple >>> [*a] = 1, 2 # 星号单独出现需放在列表/元组中 >>> a [1, 2] >>> (*a,) = 1, 2 # 1个元祖，不要忘了逗号 >>> a [1, 2] >>> for a, *b in [\"abc\", (1,2,3)]: print(a,b) #序列解包和星号收集用于控制表达式的场景 a ['b', 'c'] 1 [2, 3] 星号还可展开可迭代对象。所有序列类型、字典、集合、文件等都是可迭代类型。 >>> a = (1, 2) >>> b = \"ab\" >>> c = range(10, 13) >>> [*a, *b, *c] [1, 2, 'a', 'b', 10, 11, 12] >>> d= {\"a\": 1, \"b\": 2} >>> [*d] # 字典中，单星号展开主键 ['a', 'b'] >>> {\"c\": 3, **d} # 字典中，双星号展开键值 {'c': 3, 'a': 1, 'b': 2} 在函数调用时，可将单个对象分解成多个实参。 >>> def test(a, b, c): ... print(locals()) >>> test(*range(3)) {'a': 0, 'b': 1, 'c': 2} >>> test(*[1,2], 3) {'a': 1, 'b': 2, 'c': 3} >>> a = {\"a\": 1, \"c\":3} >>> b = {\"b\": 2} >>> test(**b, **a) {'a': 1, 'b': 2, 'c': 3} 作用域 赋值操作默认是针对当前名字空间的。 >>> g = 1 >>> def outer(): ... e = 2 ... def inner(): ... global g #声明全局变量 ... nonlocal e #声明外部嵌套函数变量 ... g = 10 ... e = 20 ... inner() ... return e ... >>> outer() 20 >>> g 10 可用global在函数内创建全局变量，用nonlocal则自内向外一次检索嵌套函数，但不包括全局名字空间。如多层嵌套函数存在同名变量，则就近原则处理，另外，nonlocal不能为外层嵌套函数新建变量。不同global运行期行为，nonlocal要求编译期绑定，故目标变量提前存在。 >>> def enclosing(): ... x = 1 ... def outer(): ... def inner(): ... nonlocal x ... x = 999 ... inner() ... outer() ... print(x) ... >>> enclosing() 999 >>> def inner(): ... nonlocal x ... File \"\", line 2 SyntaxError: no binding for nonlocal 'x' found 运算符 Python运算符接近自然表达方式。但，优先级顺序和隐式转换会导致某些隐蔽错误。 >>> not \"a\" in [\"a\", 1] # 应该先in后not False >>> (not \"a\") in [\"a\", 1] False >>> not (\"a\" in [\"a\", 1]) #使用括号，避免误解 False 图：1559027907842 运算符优先级如上图。 标准库operator提供了特定函数或方法来实现运算符，可像普通对象那样作为参数传递。 >>> def calc(x, y, op): ... return op(x, y) ... >>> import operator >>> calc(1, 2, operator.add) # operator提供了很多运算方法，可通过help(operator)查看 3 链式比较 链式比较就是将多个比较表达式组合在一起。该方法可有效缩短代码，并可提供性能以及更符合阅读习惯。 >>> a, b = 2, 3 >>> a > 0 and b > a and b >> 0切片 切片可用于表达序列片段或整体。切片操作由3个参数构成，[start: stop: step]。以起始和结束构成半开半闭区间，不含结束位置。默认起始位置为0，结束为止为len(x)，默认步长为1。 >>> x = [0, 1, 2, 3, 4, 5, 6] >>> s = x[2:5] # 从列表复制指定范围的引用 >>> s [2, 3, 4] >>> x.insert(3, 100) #修改原列表，不影响切片 >>> x [0, 1, 2, 100, 3, 4, 5, 6] >>> s [2, 3, 4] >>> x[:5] #省略起始，以0开始 [0, 1, 2, 100, 3] >>> x[2:] #省略结束，到最尾。 [2, 100, 3, 4, 5, 6] >>> x[:] #完成复制 [0, 1, 2, 100, 3, 4, 5, 6] >>> x[2:6:2] #指定步长为2 [2, 3] >>> x[::2] #从头到尾，步长为2 [0, 2, 3, 5] >>> x[::-1] #从头到尾，反向复制 [6, 5, 4, 3, 100, 2, 1, 0] >>> x[5:2:-1] #反向步进 [4, 3, 100] >>> x[-2:-5:-1] #用负索引表达起始，结束，反向步长。 [5, 4, 3] >>> x[-2] #使用负索引来直接访问序列元素 5 >>> x[3:7] [100, 3, 4, 5] >>> del x[3:7] #使用切片来删除指定范围序列 >>> x [0, 1, 2, 6] >>> del x[::2] #步进删除 >>> x [1, 6] 除表达式为也可用itertools.islice函数来执行切片操作。 以切片方式进行序列局部赋值，相当于先删除，后插入。 >>> x = [0, 1, 2, 3, 4, 5, 6] >>> x[2:6] = [10, 20] >>> x [0, 1, 10, 20, 6] >>> x = [0, 1, 2, 3, 4, 5, 6] >>> x[::2] [0, 2, 4, 6] >>> x[::2] = [10,20,40,60] #如用步进插入，则删除与插入元素必须相等。 >>> x [10, 1, 20, 3, 40, 5, 60] >>> x[::2] = [10,20,40,60,80] # 步进插入，删除与插入元素不等。 Traceback (most recent call last): File \"\", line 1, in ValueError: attempt to assign sequence of size 5 to extended slice of size 4 逻辑运算 逻辑运算用于判断多条件的布尔结果，或返回有效的操作数。 分别以and 、or、not运算符表示逻辑与、或、非三种关系。 and返回最后或导致短路的操作数；or返回第一真值，或最后操作数。 注意：相同逻辑运算符一旦短路，后续计算被终止。 >>> 1 and 2 # 最后操作数 2 >>> 1 and 0 and 2 #导致短路的操作数 0 >>> 1 or 0 #第一真值 1 >>> 0 or 1 or 2 #第一真值 1 >>> 0 or [] # 最后操作数 [] >>> def x(o): ... print(\"op:\", o) ... return o ... >>> x(0) and x(1) # 0 导致短路，后续不计算 op: 0 0 >>> x(1) or x(2) # 返回1真值，后续不计算 op: 1 1 >>> x(0) and x(1) or x(2) #不同运算符须多次计算。 op: 0 op: 2 2 条件表达式 这里介绍三元运算符。T if X else F：当条件X为真时，返回T，否者返回F。等同X?T:F。 >>> \"T\" if 2>1 else \"F\" 'T' >>> 2 > 1 and \"T\" or \"F\" 'T' >>> 2 >> 2 >> False or \"F\" #b.分解上面运算符。返回真值\"F\" 'F' >>> 2 > 1 and \"\" or \"F\" #T为假时，or必须返回最后操作数，这与预期不符。 'F' >>> \"\" if 2 > 1 else \"F\" #当T和F时动态数据时，使用表达式会更安全点。 '' >>> x = None >>> y = x or 100 #可简化设定默认值 >>> y = x and x*2 or 100 #可简化设定默认值 推导式 推导式就是整合for、if语句来构造列表、字典和集合对象。 >>> [x for x in range(5)] #列表 [0, 1, 2, 3, 4] >>> [x+10 for x in range(10) if x % 2 == 0] #条件过滤后的列表 [10, 12, 14, 16, 18] >>> {k:v for k, v in zip(\"abc\", range(10,13))} #字典，使用大括号 {'a': 10, 'b': 11, 'c': 12} >>> {x for x in \"abc\"} #集合，使用大括号 {'c', 'a', 'b'} >>> [f\"{x} {y}\" for x in \"abc\" if x!=\"c\" #多嵌套使用推导式，可用多个for子句，每个子句可选一个if条件表达式。 ... for y in range(3) if y !=0 ] ['a 1', 'a 2', 'b 1', 'b 2'] 和普通循环语句不同，推导式临时变量不影响上下文名字空间。推导式在编译器中会生成函数，其变量在自动生成函数内使用，故不会影响上下文。 >>> def test(): ... a=\"abc\" ... data = {a:b for a,b in zip(\"xyz\",range(10,13))} #这里a,b是临时变量 ... print(locals()) ... >>> test() {'a': 'abc', 'data': {'x': 10, 'y': 11, 'z': 12}} 注意：推导式中使用小括号，并非创建元组，而是创建生成器对象。区别于推导式，称为生成器表达式。 >>> (x for x in range(3)) at 0x00000213A1770A20> © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/if.html":{"url":"basic/if.html","title":"流程控制","keywords":"","body":"流程控制 IF语句 If语句就是进行流程判断，然后做出相应的处理。比如： cars = ['audi','bmw','subaru','toyota'] for car in cars: if car == 'bmw': print(car.upper()) else: print(car.title()) 条件测试 使用 == 来判断是否相等，如: car = 'bmw' car == 'bmw' # True car = 'Audi' car == 'audi' # False car.lower() == 'audi' # True 使用!=来判断是否不相等 car = 'bmw' car !='audi' #True 上面都是字符串比较，那么数字呢？除了 ==，!=外，还有小于（)，大于等于(>=)，小于等于( 如果是列表呢？就可以使用in了。如: cars = ['audi','bmw','subaru','toyota'] 'bmw' in cars # True 'apple' not in cars # True 多条件判断 使用and 和or 来进行多条件判断。 age=10 age>=6 and age10 and age=10 or ageif-else语句 当条件通过执行一个操作，没通过则执行另一个操作时，就要用到if-else语句了。 age =17 if age>=18: print('你可以选举了') else: print('对不起，你还不能选举') if-elif-else语句 多条件判断，当所有条件不满足，则执行else语句，比如： age =12 if age>4: print('免费') elif age© 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/loop.html":{"url":"basic/loop.html","title":"循环","keywords":"","body":"循环 在列表、元组及字典中经常都用到了for循环，用来对集合中每个元素进行遍历。简单来说，while执行逻辑循环；for偏向对象内容迭代。 while循环 while循环就是不断运行，直到指定条件不满足为止。比如： current =1 while current 在使用Input()函数进行输入时，希望能让用户不停输入，直到约到quit后退出。那么可使用while循环来实现。如： message = \"\" while message != 'quit': message = input(\"请输入，直到'quit'退出\") if message !='quit': print(message) break退出循环 在while循环中，可不管任何条件，都可使用break来退出循环。比如： while True: message = input(\"请输入，直到'quit'退出\") if message == 'quit': break else: print(message) 当然，除了while循环，在for循环中，一样可使用break来退出循环。 continue继续循环 如要返回循环开头，并根据条件测试结果来决定是否继续执行循环，则可使用continue语句。如，从1到10 ，只打印奇数的循环： num = 0 while num 尽量避免无限循环，在交互的情况下，如无限循环，可使用Ctrl+C来退出，然后修改代码。 while处理列表和字典 for循环可遍历列表，但不可修改列表。如要移动或者修改或者删除列表时，那么最好用while循环。 src = ['a','b','c'] dst = [] while src: current = src.pop() dst.append(current) for d in dst: print(d.title()) ## 使用remove pets = ['dog','cat','dog','fish','cat','rabbit'] while 'cat' in pets: pets.remove('cat') for迭代 遍历可迭代对象时，可进一步执行序列解包。次序是先取迭代元素，然后对该元素做解包操作。 >>> for a, b in [(1, 2), (3, 4)]: ... print(a, b) ... 1 2 3 4 >>> for a, b in [1 ,2]: #从列表取一个元素，但单个整数无法展开 ... print(a, b) ... Traceback (most recent call last): File \"\", line 1, in TypeError: cannot unpack non-iterable int object 如要实现传统for循环，可用enumerate类型。它可为迭代元素自动增加序号，如此解包操作就可获取索引值。 >>> for i, x in enumerate([100,200,300]): ... print(i, x) ... 0 100 1 200 2 300 >>> def data(): ... print(\"data\") ... return range(3) ... >>> for i in data(): #迭代对象以函数返回，该函数只调用1次。 ... print(i) ... data 0 1 2 循环语句没有单独名字空间，其内部临时变量会直接影响所在上下文。 >>> def test(): ... while True: ... x =100 ... break ... for i in range(10,20): ... pass ... print(locals()) # x ,i实际使用了test.locals名字空间 ... print(x,i) ... >>> test() {'x': 100, 'i': 19} 100 19 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/function.html":{"url":"basic/function.html","title":"函数","keywords":"","body":"函数 函数就是带名字的代码块，用来完成一些具体的事情。要执行函数定义的特定任务时，就要调用该函数。定义函数是为了在程序中能多次调用，而无需反复编写代码。使用函数，会让程序编写、阅读、测试、DEBUG都变得容易。 函数应该减少依赖关系，具备良好的可测试性和可维护性。 定义函数 函数由两部分构成：代码对象持有字节码和指令元数据，负责执行；函数对象则为上下文提供调用实例，并管理所需的状态数据。下面定义一个简单函数，如： >>> def greet(user=\"Python\"): ... s = \"Hello \" ... print(s+user.title()) ... >>> greet # 函数对象 >>> greet.__code__ #代码对象 \", line 1> >>> greet.__code__.co_varnames #参数及变量名列表 ('user', 's') >>> greet.__code__.co_consts #指令常数 (None, 'Hello ') >>> greet.__defaults__ #参数默认值 ('Python',) >>> greet('Python') #调用函数 Hello Python >>> greet.__defaults__ =('world',) #修改默认值 >>> greet() Hello World >>> greet.abc=\"hello,world\" #为函数实例添加属性 >>> greet.__dict__ #函数字典 {'abc': 'hello,world'} 上面函数传递了一个参数，那么在函数greet中，user就是参数，也可以称为形参。而调用greet('Python')中的’Python‘就是实参。greet('Python')就是将实参'Python'传递给函数greet中的形参user中。 代码对象相关属性有编译器生成，为只读模式。存储指令运行所需相关信息，如源码行、指令操作数，以及参数和变量名等。而函数对象作为外部实例存在，负责管理运行期状态，比如参数默认值及动态添加属性等。注意：def是运行期指令。以代码对象为参数，创建函数实例，并在当前上下文中与指定名字关联。故可用def以单个代码对象为模板创建多个函数实例，如下： >>> def make(n): ... ret = [] ... for i in range(n): ... def test(): print(\"hello\") # test = make_function(code) ... print(id(test), id(test.__code__)) ... ret.append(test) ... return ret ... >>> make(3) 2023541025920 2023538776224 #不同实例，相同代码 2023541026192 2023538776224 2023541026600 2023538776224 [.test at 0x000001D72471AC80>, .test at 0x000001D72471AD90>, .test at 0x000001D72471AF28>] 多个实例，和多个名字引用同一个实例，不是一回事。用列表持有多个实例，阻止临时变量test被回收，避免因内存复用而出现相同id值。 在名字空间里，名字仅能与单个目标相关联。因此，就无法实现函数重载。另外，作为第一类对象，函数可作为参数和返回值传递。 >>> def test(op, x, y): ... return op(x, y) ... >>> def add(x, y): ... return x+y ... >>> test(add, 1, 2) #将函数作为参数 3 >>> def test(): ... def hello(): ... print(\"hello world\") ... return hello #将函数作为返回值 ... >>> test() .hello at 0x000001D72471AD90> >>> test()() hello world >>> def test(): #支持函数嵌套，甚至可与外层函数同名。内外函数虽同名，但属于不同名字空间 ... print(\"outer test\") ... def test(): ... print(\"inner test\") ... return test ... >>> x = test() outer test >>> x .test at 0x000001D72471AC80> >>> x() inner test 匿名函数 匿名函数的正式名称为lambda表达式。 相比普通函数，匿名函数内容只能是单个表达式，而不能使用语句，也不能提供默认函数名。 >>> add = lambda x, y: x+y >>> add at 0x000001D72471AD90> >>> add(1,2) 3 普通函数有个默认名字(__name__)，用来标识真实身份。该名字是编译期静态绑定的，与运行期的变量名引用无关。 >>> def test(): pass ... >>> a = test >>> a.__name__ 'test' >>> a >>> test = lambda: None >>> a = test >>> a.__name__ '' >>> a at 0x000001D72471AF28> 在某些合适场合，lambda比普通函数更灵活与自由。 >>> map(lambda x: x**2, range(3)) #直接作为参数 >>> ops = { #构建方法表 ... \"add\": lambda x, y: x+y, ... \"sub\": lambda x, y: x-y, ... } >>> ops[\"add\"](2,3) 5 >>> def make(n): # 作为推导式输出结果 ... return [lambda: print(\"hello\") for i in range(n)] #lambda支持嵌套，还可直接调用。 >>> test = lambda x: (lambda y: x+y) #将另一个lambda作为返回值，支持闭包 >>> add= test(2) >>> add(3) 5 >>> (lambda x: print(x))(\"hello\") #使用括号避免语法错误 hello 参数 上面简单解释了实参与形参。那么如果有多个参数怎么传递呢？调用函数时，每个实参都需要关联到函数定义的形参中，最简单的关联方式就是基于实参的位置。比如： def desc_pet(type,name): print(\"宠物类型为：\"+type) print(\"宠物名称为：\"+name) desc_pet('hamster','harry') desc_pet('cat','jerry') 注意：函数调用实参顺序和函数定义的形参顺序要一致，不然就会错误。 如果不关注参数位置，则可通过形参关键字来调用。比如： desc_pet(name='micky',type='mouse') 使用关键字实参时，必须要准确的指定函数定义中的形参名。 定义函数时，还可以指定默认值，如不传入实参，则按缺省值来提供。比如： def desc_pet(name,type='dog'): print(\"宠物类型为：\"+type) print(\"宠物名称为：\"+name) desc_pet('harry') 有默认值的形参最好放在最后，这样进行位置传送时就不宜出错，不然要就需要指定形参名。 形参出现在函数定义的参数列表中，可视作函数局部变量，仅能在函数内部使用。而实参由调用方提供，通常以复制方式将值传递给形参。形参在函数调用后销毁，而实参则受调用方作用域影响。不同形参以变量形式存在，实参可是变量、常量、表达式等，总之有确定值可供复制传递。不管实参是名字、引用，还是指针，其都以值复制方式传递，随后的形参变化不会影响实参。当然，对该指针或引用目标的修改，与此无关。 >>> def test(a, b, c =3): ... print(locals()) ... >>> test(1,2) # 忽略有默认值参数 {'a': 1, 'b': 2, 'c': 3} >>> test(1,2,30) #为默认值参数提供实参 {'a': 1, 'b': 2, 'c': 30} >>> test(*(1,2,30)) #星号展开 {'a': 1, 'b': 2, 'c': 30} >>> test(b =2, a=1) #命名方式传递，可不理会参数顺序 {'a': 1, 'b': 2, 'c': 3} >>> test(**{\"b\":2, \"a\":1}) #键值展开后，等同命名传递 {'a': 1, 'b': 2, 'c': 3} >>> test(1, c=30, b =2) #命名与顺序混用时，必须顺序在命名参数前 {'a': 1, 'b': 2, 'c': 30} 传递列表参数 形参可接收任何类型，如传入列表，字典等。如果传入列表后，希望不能修改列表怎么处理呢？那么传入实参时，可传入实参的副本。比如: def love_pets(pets): for pet in pets: print(pet) pets = ['dog','cat','goldfish'] love_pets(pets) #传入的实参可在函数中修改 love_pets(pets[:]) #传入实参列表的副本到函数，不影响实参。 向函数传递列表副本可保留原始列表的内容，但除非有充分理由需要传递副本，否则还是传递原始列表给函数，因为函数使用现成列表可避免花时间和内存来创建副本，从而提供效率。 任意数量参数 有些函数定义时并不知道有多少实参，那么函数定义形参时加入*，表示可接收任意数量参数，也可称为收集参数。比如： def make_pizza(*toppings): print(toppings) make_pizza('pepperoni') make_pizza('mushrooms','green peppers','extra cheese') 如函数接收不同类型实参，那么可接纳任意数量实参的形参必须放在最后，比如: def make_pizza(size,*toppings): print(size) print(toppings) make_pizza(16,'pepperoni') make_pizza(12,'mushrooms','green peppers','extra cheese') 单星号收集参数，只能一个。但普通位置参数以及默认值位置参数可0到多个。收集参数也不可命名传递。 有时，需要接收任意数量的实参，而且不知道会传递给函数什么参数。这时，可将函数编写成接收任意数量键值对，使用**来标识。也称为键值收集参数。比如: def build_profile(first,last,**user_info): profile ={} profile['first_name']=first profile['last_name']=last for key, value in user_info.items(): profile[key]=value return profile user_profile = build_profile('albert','lee',location='hubei',field='physics') print(build_profile) 编写函数时，可以各种方式混合使用位置实参，关键字实参和任意数量参数。 Python3中新增了名为keyword-only的键值参数类型 。 以星号与位置参数列表分割边界； 普通keyword-only参数，0到多个； 有默认值的keyword-only参数，0到多个； 双星号键值收集参数，仅1个。 无默认值的keyword-only必须显示命名传参，否则视为普通位置参数。 >>> def test(a,b,*,c): ... print(locals()) ... >>> test(1,2,3) Traceback (most recent call last): File \"\", line 1, in TypeError: test() takes 2 positional arguments but 3 were given >>> test(1,2) Traceback (most recent call last): File \"\", line 1, in TypeError: test() missing 1 required keyword-only argument: 'c' >>> test(1,2,c=3) {'a': 1, 'b': 2, 'c': 3} 即使没有位置参数，keyword-only也必须按规则传递。 >>> def test(*,c):pass ... >>> test(1) Traceback (most recent call last): File \"\", line 1, in TypeError: test() takes 0 positional arguments but 1 was given >>> test(c=1) 除单星号外，位置收集参数(*args)也可作为边界。但只取其一，不能同时出现。 >>> def test(a, *args, c, d=99, **kwargs): ... print(locals()) ... >>> test(1, 2, 3, c=88, x=10, y=20) {'a': 1, 'c': 88, 'd': 99, 'args': (2, 3), 'kwargs': {'x': 10, 'y': 20}} 同样不能对键值收集参数命名传参。否则，会被当做普通参数收集。 >>> def test(**kwargs): ... print(kwargs) ... >>> test(kwargs={\"a\":1, \"b\":2}) #被当着普通键值参数收集，kwargs[\"kwargs\"] {'kwargs': {'a': 1, 'b': 2}} >>> test(**{\"a\":1, \"b\":2}) #这样才正确 {'a': 1, 'b': 2} 静态局部变量可在不用外部变量的情况下维持函数状态。比如，用来存储调用计数等。但相比于参数默认值，正确做法是为函数创建一个状态属性。毕竟变量为函数内部使用，而参数属于对外接口。所创建的属性与函数对象的生命周期相同，不会调用结束就终结。 >>> def test(): ... test.__count__ = hasattr(test,\"__count__\") and test.__count__ + 1 or 1 ... print(test.__count__) ... >>> test() 1 >>> test() 2 默认值 参数默认值允许省略实参传值。默认值在函数对象创建生成，保存在__defaults__中，为每次调用共享。 >>> def test(a, x =[1,2]): ... x.append(a) ... print(x) ... >>> test.__defaults__ ([1, 2],) >>> test(3) [1, 2, 3] >>> def test(a, x = None): 如默认值为不可变类型，建议以None表示可忽略 ... x = x or [] # 忽略时，主动新建 ... x.append(a) ... return x ... >>> test(1) [1] >>> test(3,[1,4]) #提供非默认值实参 [1, 4, 3] 形参赋值 解释器对形参赋值的过程如下。 1、按顺序对位置参数赋值； 2、按命名方式对指定参数赋值； 3、收集多余的位置参数； 4、收集多余的键值参数； 5、为没有赋值的参数设置默认值； 6、检查参数列表，确保非收集参数都已经赋值。 收集参数args、kwargs属于习惯性命名，非强制要求 而实参也有一定规则： 无默认值参数，必须有实参传入； 键值参数总是以命名方式传入； 不能对同一参数重复传值。 如设计显示函数如下： def printx(*objects, sep =\",\", end=\"\\n\") 参数分2部分，待显示对象为主，可省略显示设置为次。待显示对象为外部资源，设置项用于控制函数自身行为。 用Python3的keyword-only参数则可解决此问题； >>> def printx(*objects, sep=\",\", end =\"\\n\"): ... print(locals()) ... >>> printx(1,2,3) {'sep': ',', 'end': '\\n', 'objects': (1, 2, 3)} >>> printx(1,2,3,sep=\"|\") {'sep': '|', 'end': '\\n', 'objects': (1, 2, 3)} 返回值 函数可以处理后返回一个或一组值。函数返回的值称为返回值。必须使用return来返回，一旦返回，则函数停止执行。 def format_name(first_name,last_name): return fist_name+' '+last_name print(format_name('jack','ma')) 如果上面函数需要提供中间名，而中间名并非必须呢？也就是希望参入的实参是可选的，那上面函数可修改为： def format_name(first_name,last_name, mid_name=''): return fist_name+' '+mid_name+ ' '+last_name print(format_name('john','lee','hooker')) print(format_name('jack','ma')) 如果要将返回值返回为一个更复杂的类型，比如字典呢？那上面函数可修改为： def format_name(first_name,last_name, mid_name=''): person = {'first':first_name,'last':last_name,'mid':mid_name,} return person 从实现角度看，只要返回数量多于一，编译器就将其打包成元组对象。 >>> def test(a, b): ... return \"hello\", a +b ... >>> x =test(1,2) >>> type(x) >>> x ('hello', 3) >>> def test(): pass # 默认返回None ... >>> x = test() >>> type(x) >>> x >>> def test(): return # 默认返回None ... >>> x = test() >>> type(x) >>> x 作用域 在函数内访问变量，会以特定顺序依次查找不同层次的作用域。 >>> import builtins >>> builtins.B=\"B\" >>> G=\"G\" >>> def enclosing(): ... E=\"E\" ... def test(): ... L=\"L\" ... print(L,E,G,B) ... return test ... >>> enclosing()() L E G B 以上可称为LEGB规则。 LEGB含义解释： L-Local(function)；函数内的名字空间 E-Enclosing function locals；外部嵌套函数的名字空间(例如closure) G-Global(module)；函数定义所在模块（文件）的名字空间 B-Builtin(Python)；Python内置模块的名字空间 名字空间也叫命名空间，简单点说，命名空间是对变量名的分组划分，在Python中一切皆对象，所以变量名就是字符串对象。如 >>> a = 10 # 建立字符串对象a与Number对象10之间对应映射关系。 >>> locals() # 上面变量名以键值形式来表示！ {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': , '__spec__': None, '__annotations__': {}, '__builtins__': , 'a': 10} 从上可看出命名空间就是对许多键值对分组划分，及键值对的集合，总结下就是：Python的命名空间是一个字典，字典保存了变量名称与对象之间的映射关系。 那么查找变量名其实就是在命名空间字典中查找键值对。Python中有多个命名空间，因此，需要有规则来规定，按怎样顺序来查找命名空间。而LEGB规则就是来规定命名空间查找顺序的规则。 ​ LEGB规定了查找一个名称的顺序为：local-->enclosing function locals-->global-->builtin 图：1559182801747 例如： >>> x = 1 >>> def foo(): ... x =2 ... def innerfoo(): ... x = 3 # 如注释后，结果会怎样呢？ ... print('locals', x) ... innerfoo() ... print('enclosing function locals', x) ... >>> foo() locals 3 enclosing function locals 2 >>> print('global', x) global 1 从上例子，解释下，从内到外，依次形成四个命名空间： def innerfoo(): Local,即函数外部命名空间； def foo():Enclosing funciton locals;外部嵌套函数的名字空间; module: Global(module)；函数定义所在模块(文件)的名字空间; Python内置模块的名字空间: Builtin 如将x =3这句注释掉呢？x =3本属函数内部命名空间，注释掉后，函数innerfoo内部使用变量名x时，就会触发名称查找动作。在Local命名空间找不到，就会去Enclosing funciton locals命名查找，如找到就调用，如找不到就会继续向上查找。但总的都要遵循LEGB规则。 内存结构 函数每次调用，都会新建栈帧，用于局部变量和执行过程存储。等执行结束，栈帧内存被回收，同时释放相关对象。 >>> def test(): ... print(id(locals())) ... >>> test() 2082488697984 >>> test() 2082488697984 以字典实现的名字空间，虽灵活，但访问效率不高。为此，解释器有专门的内存空间，用效率最快的数组来替代字典。在函数指令执行前，先将包含参数在内的所有局部变量，以及要使用的外部变量复制（指针）到该数组。基于作用域不同，此内存可简单分为2部分：FAST和DEREF。这样，操作指令用索引就可立即读取或存储目标对象，这比哈希查找过程要高效。从反编译来看，有大量类似LOAD_FAST指令，其参数就是索引号。 >>> def enclosing(): ... E = \"E\" ... def test(a, b): ... c= a+b ... print(E, c) ... return test ... >>> t = enclosing() # 返回test函数 >>> t.__code__.co_varnames #局部变量列表(含参数)。与索引号对应 ('a', 'b', 'c') >>> t.__code__.co_freevars #所引用的外部变量列表。与索引号对应 ('E',) >>> import dis >>> dis.dis(t) 4 0 LOAD_FAST 0 (a) #从FAST区域，以索引号访问并载入 2 LOAD_FAST 1 (b) 4 BINARY_ADD 6 STORE_FAST 2 (c) #结果存入FAST区域 5 8 LOAD_GLOBAL 0 (print) 10 LOAD_DEREF 0 (E) # 从DEREF区域，访问并载入外部变量 12 LOAD_FAST 2 (c) 14 CALL_FUNCTION 2 16 POP_TOP 18 LOAD_CONST 0 (None) 20 RETURN_VALUE FAST和DEREF数组大小是统计参数和变量得来的，对应索引值在编译期确定。故，不能在运行期扩。global关键字可向全局名字空间新建名字，但nonlocal却不可以。原因就是nonlocal代表外层函数，无法动态向其FAST数组插入或追加新元素。另外LEGB中的E保存在DEREF数组，相应查找过程也被优化，无需去迭代调用堆栈。所以，LEGB是针对远吗，而不是内部实现。 名字空间 除非调用函数，否则函数执行期间，不会创建名字空间字典。也就是说，函数返回字典是按需延迟创建的，并从FAST区域赋值相关信息得来的。 >>> def test(): ... locals()[\"x\"] = 100 # 运行期通过名字空间新建变量 ... print(x) # 编译此指定时，本地并没有x这个名字 ... >>> test() # 失败 Traceback (most recent call last): File \"\", line 1, in File \"\", line 3, in test NameError: name 'x' is not defined >>> import dis >>> dis.dis(test) 2 0 LOAD_CONST 1 (100) 2 LOAD_GLOBAL 0 (locals) 4 CALL_FUNCTION 0 6 LOAD_CONST 2 ('x') 8 STORE_SUBSCR 3 10 LOAD_GLOBAL 1 (print) 12 LOAD_GLOBAL 2 (x) # 编译时确定，从全局而非FAST载入 14 CALL_FUNCTION 1 16 POP_TOP 18 LOAD_CONST 0 (None) 20 RETURN_VALUE 显然，名字使用静态作用域。运行期行为，对此并无影响。而另一方面，locals名字空间不过是FAST复制品，对其变更不会同步到FAST区域。 >>> def test(): ... x = 100 ... locals()[\"x\"] = 999 #新建字典，进行复制。对复制品修改不影响FAST ... print(\"fast.x=\" , x) ... print(\"locals.x=\", locals()[\"x\"]) ... >>> test() fast.x= 100 locals.x= 100 globals能新建全局变量，并影响外部环境，是因为模块直接以字典实现名字空间，没有类似FAST机制 栈帧会缓存locals函数所返回的字典，以避免每次都新建。故，可用它存储额外的数据，比如向后续逻辑提供上下文状态等。注意：只有再次调用locals函数，才会刷新字典数据。 >>> def test(): ... x = 1 ... d = locals() ... print(d is locals()) # 每次返回同一字典对象 ... d[\"context\"] = \"hello\" # 存储额外数据 ... print(d) ... x = 999 # 修改FAST时，不会主动刷新locals字典 ... print(d) # 依旧输出上次调用locals结果 ... print(locals()) # 刷新操作由locals调用触发 ... print(d) # 返回刷新后结果 ... >>> test() True {'x': 1, 'd': {...}, 'context': 'hello'} {'x': 1, 'd': {...}, 'context': 'hello'} {'x': 999, 'd': {...}, 'context': 'hello'} {'x': 999, 'd': {...}, 'context': 'hello'} 静态作用域 >>> def test(): ... if False: x = 100 ... print(x) ... >>> test() Traceback (most recent call last): File \"\", line 1, in File \"\", line 3, in test UnboundLocalError: local variable 'x' referenced before assignment >>> dis.dis(test) 3 0 LOAD_GLOBAL 0 (print) 2 LOAD_FAST 0 (x) 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 0 (None) 10 RETURN_VALUE 从上代码可看到编译器将死代码剔除了。但x作用域还是不变的，依然是本地变量。 >>> def test(): ... if False: global x # 死代码 ... x = 100 ... >>> dis.dis(test) 3 0 LOAD_CONST 1 (100) 2 STORE_GLOBAL 0 (x) # x 作用域为GLOBAL 4 LOAD_CONST 0 (None) 6 RETURN_VALUE 总结 函数最好设计为纯函数，仅依赖参数、内部变量和自身属性；如依赖外部状态，会给重构和测试带来麻烦。也可将外部依赖变成keyword-only参数，这样测试就可自动以依赖环境，以确保最终结果一致。如必须依赖外部变量，则尽量不修改，以返回值交给调用方决策。 纯函数输出与输入以外的状态无关，没有任何隐式依赖。相同输入总是输出相同结果，且不对外部环境产生影响。 闭包 闭包是指函数离开生成环境后，依然可记住，并持续引用语法作用域里的外部变量。 >>> def make(): ... x = [1, 2] ... return lambda: print(x) ... >>> a = make() >>> a() [1, 2] 上面代码x作用域是make栈帧，调用结束后就应该销毁。但所返回匿名函数还可访问x变量，这就是闭包效应。 闭包不等于函数，只是形式上返回函数而已。因引用外部状态，闭包函数也不是纯函数。应闭包会延长环境变量生命周期，应慎重使用。 创建 闭包由2部分组成，其创建过程为： 打包环境变量； 将环境变量作为参数，新建要返回的函数对象。 因生命周期改变，环境变量存储区从FAST转移到DEREF。闭包函数可以是匿名函数，也可是普通函数。 >>> def make(): ... x = 100 ... def test(): print(x) ... return test ... >>> dis.dis(make) 2 0 LOAD_CONST 1 (100) 2 STORE_DEREF 0 (x) # 保存到DEREF 3 4 LOAD_CLOSURE 0 (x) # 闭包环境变量 6 BUILD_TUPLE 1 8 LOAD_CONST 2 (\", line 3>) 10 LOAD_CONST 3 ('make..test') 12 MAKE_FUNCTION 8 # 创建函数时包含闭包参数 14 STORE_FAST 0 (test) 4 16 LOAD_FAST 0 (test) 18 RETURN_VALUE Disassembly of \", line 3>: 3 0 LOAD_GLOBAL 0 (print) 2 LOAD_DEREF 0 (x) 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 0 (None) 10 RETURN_VALUE >>> f = make() # 闭包函数得从DEREF读取环境变量 >>> dis.dis(f) 3 0 LOAD_GLOBAL 0 (print) 2 LOAD_DEREF 0 (x) # 从DEREF载入闭包环境变量 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 0 (None) 10 RETURN_VALUE 自由变量 闭包所引用的环境变量也被称为自由变量，它保存在函数对象的__closure__属性中。 >>> def make(): ... x = [1, 2] ... print(hex(id(x))) ... return lambda: print(x) ... >>> f = make() 0x1ff1db77ac8 >>> f.__closure__ (,) >>> f() [1, 2] >>> f.__code__.co_freevars #当前函数引用外部自由变量列表 ('x',) >>> make.__code__.co_cellvars # 被内部闭包函数引用的变量列表 ('x',) 自由变量保存在函数对象里，那多次调用是否被覆盖？不会，因为所返回的函数对象也是每次新建的。创建闭包等于“新建函数对象，附加自由变量” >>> def make(x): ... return lambda: print(x) ... >>> a = make([1, 2]) >>> b = make(100) >>> a is b # 每次返回新的函数对象实例 False >>> a.__closure__ # 自由变量保存在各自独立的函数实例中 (,) >>> b.__closure__ (,) 多个闭包函数可共享同一自由变量。 >>> def queue(): ... data = [] ... push = lambda x: data.append(x) ... pop = lambda: data.pop(0) if data else None ... return push ,pop ... >>> push, pop = queue() >>> push.__closure__ #共享自由变量 (,) >>> pop.__closure__ (,) >>> for i in range(10, 13): ... push(i) ... >>> while True: ... x = pop() ... if not x: break ... print(x) ... 10 11 12 自引用 在函数内引用函数自己，也可构成闭包。当def创建函数对象后，会在当前名字空间将其与函数名字关联。因此，该函数实例自然也可作为自由变量。 >>> def make(x): ... def test(): ... test.x = x ... print(test.x) ... return test ... >>> a, b = make(1234), make([1, 2]) >>> a.__closure__ # 自由变量列表中包含自己 (, ) >>> b.__closure__ (, ) >>> a() 1234 >>> b() [1, 2] 延迟绑定 闭包只是绑定自由变量，并不会立即计算引用内容。只有当闭包函数执行时，才访问所引用的目标对象。这样就有所谓的延迟绑定现象。 >>> def make(n): ... x = [] ... for i in range(n): ... x.append(lambda: print(i)) ... return x ... >>> a, b, c =make(3) >>> a(), b(), c() 2 2 2 (None, None, None) >>> a.__closure__ (,) >>> b.__closure__ (,) >>> c.__closure__ (,) 为啥输出是2,2,2，而不是0,1,2呢？分析下执行次序： make创建并返回3个闭包函数，引用同一个自由变量i； make执行结束，i等于2； 执行闭包函数，引用并输出i的值，自然都是2。 从__closure__来看，函数并不直接存储自由变量，而是cell包装对象，以此间接引用目标。 每个自由变量都被打包成一个cell。循环期间虽然cell也和i一样引用不同整数对象，但这对尚未执行的闭包函数没有影响。循环结束，cell引用目标确定下来，这才是闭包函数执行时的输出结果。 那将上面函数修改下，复制自由变量后输出呢？ >>> def make(n): ... x = [] ... for i in range(n): ... c = i # 复制对象，然后输出，但这是一个坑。。 ... x.append(lambda: print(c)) ... return x ... >>> a, b, c =make(3) >>> a(), b(), c() 2 2 2 (None, None, None) >>> a.__closure__ # 自由变量列表还是同一个对象 (,) >>> b.__closure__ (,) >>> c.__closure__ (,) >>> def make(n): ... x = [] ... for i in range(n): ... x.append(lambda o=i: print(o)) # 函数创建就计算的参数默认值，这样可不共享变量 ... return x ... >>> a, b, c =make(3) >>> a(), b(), c() 0 1 2 (None, None, None) >>> a.__closure__ # 不是闭包了。 >>> b.__closure__ >>> c.__closure__ >>> make.__code__.co_cellvars () 为啥呢？匿名函数参数o是私有变量，设置默认值时，其复制当前i引用。虽然只有一个变量i，但在循环工程中，它指向不同的整数对象。所以，复制的引用也就不同。最重要就是没有闭包了。 闭包具备封账特征，可实现隐式上下文状态，并减少参数。在设计上，其可部分替代全局变量，或将执行环境与调用接口分离。但其对自由变量隐式依赖，会提升代码复杂度，这直接影响测试和维护，自由变量生命周期的提升，也会提高内存占用。 调用 函数调用时，会专门为其分配用户栈内存。用户栈内存除用来存储变量外，还包括字节码参数和返回值所需空间。对系统指令来说，只是存放用户指令数据。 >>> def add(a, b): ... c = a+b ... return c ... >>> dis.dis(add) 2 0 LOAD_FAST 0 (a) # 从FAST读取参数a,压入用户栈 2 LOAD_FAST 1 (b) # 从FAST读取参数b,压入用户栈 4 BINARY_ADD # 系统指令从用户栈读取操作数，执行加法操作 6 STORE_FAST 2 (c) # 将结果返回FAST 3 8 LOAD_FAST 2 (c) 10 RETURN_VALUE 进程内存分为堆(heap)和栈(stack)两类：堆可自由申请，通过指针存储自由数据；而栈则用于指令执行与线程绑定。函数调用和执行都依赖线程栈存储上下文和执行状态。 比如，在函数A内调用函数B，需确保B结束后能回到A，并继续执行后续指令。这要求将A的后续指令地址预先存储起来。调用堆栈(call stack)的基本用途便是如此。 除返回地址外，还需为函数提供参数、局部变量存储空间。按不同调用约定，甚至为被调用函数提供参数和返回值内存。在线程栈内存里，每个被调用函数都有一块栈帧(stack frame)。 在栈帧内，变量内存固定不变，执行内存视具体指令重复使用。 >>> def add(x, y): ... return x+y ... >>> def test(): ... x =10 ... y = 20 ... z = add(x,y) ... print(z) ... >>> dis.dis(test) 2 0 LOAD_CONST 1 (10) 2 STORE_FAST 0 (x) 3 4 LOAD_CONST 2 (20) 6 STORE_FAST 1 (y) 4 8 LOAD_GLOBAL 0 (add) # 将待调用函数add入栈 10 LOAD_FAST 0 (x) # 将变量x入栈 12 LOAD_FAST 1 (y) # 将变量y入栈 14 CALL_FUNCTION 2 # 调用函数(这里2位参数数量) 16 STORE_FAST 2 (z) # 将返回值从栈保存到变量区 5 18 LOAD_GLOBAL 1 (print) 20 LOAD_FAST 2 (z) 22 CALL_FUNCTION 1 24 POP_TOP # 清除print返回值，确保栈平衡 26 LOAD_CONST 0 (None) 28 RETURN_VALUE 调用堆栈一般用在调试工具中，用于检视调用过程，以及各级环境变量取值。 >>> def A(): ... x = \"func A\" ... B() ... >>> def B(): ... C() ... >>> def C(): ... f = sys._getframe(2)# 访问堆栈内不同层级栈帧对象，0位当前函数，1位上级，2为上2级，获取A栈帧 ... print(f.f_code) # A代码对象 ... print(f.f_locals) # A名字空间(此时运行期) ... print(f.f_lasti) # A最后执行指令偏移量(以确定继续执行位置) ... >>> import sys >>> A() \", line 1> {'x': 'func A'} 6 >>> dis.dis(A) 2 0 LOAD_CONST 1 ('func A') 2 STORE_FAST 0 (x) 3 4 LOAD_GLOBAL 0 (B) 6 CALL_FUNCTION 0 8 POP_TOP 10 LOAD_CONST 0 (None) 12 RETURN_VALUE >>> import inspect #标准库inspect，提供很多函数可查看线程的栈帧等 >>> def A(): B() ... >>> def B(): C() ... >>> def C(): ... for f in inspect.stack(): ... print(f.function, f.lineno) ... >>> A() C 2 B 1 A 1 1 >>> import sys >>> sys.setrecursionlimit(50) # 设置递归次数。可通过getrecursionlimit查看 >>> def test(): ... test() #递归调用 ... >>> test() Traceback (most recent call last): File \"\", line 1, in File \"\", line 2, in test File \"\", line 2, in test File \"\", line 2, in test [Previous line repeated 46 more times] RecursionError: maximum recursion depth exceeded 对已有函数，可通过包装形式改变其参数列表。使其符合特定调用接口。 >>> def test(a, b, c): ... print(locals()) >>> import functools >>> t = functools.partial(test, b = 2, c = 3) >>> t(1) {'a': 1, 'b': 2, 'c': 3} 包装函数会将相关参数合并后，再调用原目标。 基本合并规则： 1、包装位置参数优先； 2、调用键值参数覆盖包装键值参数； 3、合并后不能对单个目标参数多次赋值。 >>> functools.partial(test, 1, 2)(3) # 包装位置优先 {'a': 1, 'b': 2, 'c': 3} >>> functools.partial(test, 1, c=3)(2, c=100) #调用键值参数覆盖包装参数 {'a': 1, 'b': 2, 'c': 100} >>> t = functools.partial(test, 1, c = 3) >>> t.func # 原目标函数 >>> t.args # 包装位置参数 (1,) >>> t.keywords # 包装键值参数 {'c': 3} © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/iterator.html":{"url":"basic/iterator.html","title":"迭代器","keywords":"","body":"迭代器 概述 迭代就是重复从对象中获取数据，直到结束。在Python中就是用__iter__方法返回一个实现了__next__方法的迭代器对象。 实现_iter\\_方法就表示目标为可迭代类型，允许执行手动或自动迭代操作。该方法新建并返回一个迭代器实例。随后，通过调用__next__依次返回结果，直到抛出StopIteration异常来表示结束。 可迭代类型可以是序列数据，也可按前后顺序操作的栈、队列，以及随机返回键值的哈希表等。 >>> from collections import abc >>> issubclass(list, abc.Iterable) True >>> isinstance(range(3), abc.Iterable) True >>> isinstance(zip([1, 2]), abc.Iterable) True 自定义类型 按迭代器流程及操作方式，来逐一实现，以便更好理解。 >>> class Data: ... def __init__(self, n): ... self.data = list(range(n)) ... def __iter__(self): ... return DataIter(self.data) >>> class DataIter: ... def __init__(self, data): ... self.data = data ... self.index = 0 ... def __next__(self): ... if not self.data or self.index >= len(self.data): ... raise StopIteration ... d = self.data[self.index] ... self.index += 1 ... return d ... >>> d = Data(2) # 手工迭代 >>> x = d.__iter__() >>> x.__next__() 0 >>> x.__next__() 1 >>> x.__next__() Traceback (most recent call last): File \"\", line 1, in File \"\", line 7, in __next__ StopIteration >>> for i in Data(2): print(i) #自动迭代 ... 0 1 >>> x = Data(2).__iter__() # x是可迭代类型。 >>> x.__iter__() # x缺少__iter__方法实现，无法使用。当然可添加__iter__方法，如返回自身 Traceback (most recent call last): File \"\", line 1, in AttributeError: 'DataIter' object has no attribute '__iter__' 辅助函数 上例的列表容器已经实现迭代接口，直接返回即可。也就是按名字规定，不应直接调用__iter方法，而改用iter函数。 >>> class Data: ... def __init__(self, n): ... self.data = list(range(n)) ... def __iter__(self): ... return iter(self.data) ... >>> Data(2).__iter__() 作为辅助函数，iter还可为序列对象(__getitem__)自动创建迭代器包装。 >>> class Data: ... def __init__(self, n): ... self.n = n ... def __getitem__(self, index): ... if index=self.n: raise IndexError ... return index + 100 ... >>> iter(Data(2)) iter还可对函数、方法等可调用类型进行包装。其用在网络和文件等I/O数据接收方面，比循环语句更优雅些。 >>> x = lambda: input(\"n:\") # 被__next__调用，无参数 >>> for i in iter(x, \"end\"): print(i) # 函数x的返回值等于end时结束 ... n:1 1 n:2 2 n:end 与__next__方法对应的是next函数，用于手动迭代。 >>> x = iter([1, 2]) >>> while True: ... try: ... print(next(x)) ... except StopIteration: ... break ... 1 2 自动迭代 使用for循环语句，编译器会生成迭代相关指令，以实现对协议方法的调用。 >>> def test(): ... for i in [1, 2]: print(i) ... >>> import dis >>> dis.dis(test) 2 0 SETUP_LOOP 20 (to 22) 2 LOAD_CONST 1 ((1, 2)) 4 GET_ITER #调用__iter__返回迭代器对象(或包装) >> 6 FOR_ITER 12 (to 20) #调用__next__返回数据，结束则跳转 8 STORE_FAST 0 (i) 10 LOAD_GLOBAL 0 (print) 12 LOAD_FAST 0 (i) 14 CALL_FUNCTION 1 16 POP_TOP 18 JUMP_ABSOLUTE 6 # 继续迭代 >> 20 POP_BLOCK # 迭代结束 >> 22 LOAD_CONST 0 (None) 24 RETURN_VALUE 生成器 生成器是迭代器进化版本，用函数和表达式替代接口方法。生成器函数的特殊之处在其内部以yield返回迭代数据。无论内部逻辑怎样，其函数调用总是返回生成器对象。随后，以普通迭代器方式继续操作。 >>> def test(): ... yield 1 ... yield 2 ... >>> test() # 函数调用返回生成器对象 >>> for i in test(): print(i) # 以普通方式迭代数据 ... 1 2 每句yield语句对应一次__next__调用。可分列多条，或出现在循环语句中。只要结束函数流程，就相当于抛出迭代终止异常。 >>> def test(): ... for i in range(10): ... yield i+100 ... if i>=1: return ... >>> x = test() >>> next(x) 100 >>> next(x) 101 >>> next(x) Traceback (most recent call last): File \"\", line 1, in StopIteration >>> for i in test(): print(i) ... 100 101 子迭代器 如果数据源本身就是可迭代对象，那么可使用yield from子迭代器语句。和在for循环中用yield并无不同，只是语法更简练。 >>> def test(): ... yield from \"ab\" ... yield from range(3) ... >>> for i in test(): print(i) ... a b 0 1 2 生成器表达式 除使用小括号外，与推导式完全相同。 >>> x = (i+100 for i in range(8) if i % 2 ==0) >>> x at 0x00000265BEC7D138> 生成器表达式可被当做函数调用参数。 >>> def test(x): ... print(x) ... for i in x: print(i) ... >>> test(i for i in range(3)) at 0x00000265BEC7D048> 0 1 2 执行 相比普通迭代器，生成器的执行过程会复杂点。 首先，编译器会为生成器函数添加标记。对此类函数，解释器并不直接执行。而是将栈帧和代码作为参数，创建生成器实例。 >>> def test(n): ... print(\"gen.start\") ... for i in range(n): ... print(f\"gen.yield {i}\") ... yield i ... print(\"gen.resume\") ... >>> test.__code__.co_flags # generator 99 >>> import inspect >>> inspect.isgeneratorfunction(test) True >>> x = test(2) >>> x.gi_frame.f_locals #栈帧内存储的函数调用参数 {'n': 2} >>> x.gi_code # 关联用户函数 \", line 1> >>> x.__next__ # 实现迭代器协议方法 >>> next(x) # 第一次执行，执行到yield指令时，设置返回值，解释器保存线程状态 gen.start # 并挂起当前函数流程，只有再次调用__next__方法，才恢复状态，继续 gen.yield 0 # 执行。如此，以yield切换分界线，往复交替，知道函数结束 。 0 >>> next(x) gen.resume gen.yield 1 1 >>> next(x) gen.resume Traceback (most recent call last): File \"\", line 1, in StopIteration 方法 生成器另一进化特征，就是提供双向通信能力。生成器不单是简单的数据提供方，还可作为接收方存在。生成器甚至能在外部停止迭代，或发送信号实现重置等自定义行为。 方法send除可向yield传送数据外，其他与next完全一致。不过发送前，生成器必须已经启动。只有这样，才可进入函数执行流程，才会对外提供数据和交互。 >>> def test(): ... while True: ... v = yield 200 ... print(f\"resume {v}\") ... >>> x = test() >>> x.send(None) # 必须用next或send(None)启动生成器 200 >>> x.send(100) # 可发送任何数据，包括None,这与启动参数无关 resume 100 200 对生成器函数而言，挂起点是一个安全位置，相关状态被临时冻结。 调用close方法，解释器将终止生成器迭代。 >>> def test(): ... for i in range(10): ... try: ... yield i ... finally: ... print(\"finally\") ... >>> x = test() >>> next(x) # 启动生成器 0 >>> x.close() # 终止生成器 finally >>> next(x) # 已经终止 Traceback (most recent call last): File \"\", line 1, in StopIteration 还可像send发送数据一样，向生成器throw指定异常作为信号。 >>> class ExitException(Exception): pass >>> class ResetException(Exception): pass >>> def test(): ... while True: ... try: ... v = yield ... print(f\"recv: {v}\") ... except ResetException: ... print(\"reset.\") ... except ExitException: ... print(\"exit.\") ... return ... >>> x = test() >>> x.send(None) # 启动生成器 >>> x.throw(ResetException) # 发送重置信号 reset. >>> x.send(1) # 可继续发送数据 recv: 1 >>> x.throw(ExitException) # 发送终止信号 exit. Traceback (most recent call last): File \"\", line 1, in StopIteration >>> x.send(2) # 生成器已经终止 Traceback (most recent call last): File \"\", line 1, in StopIteration 模式 生产消费模型 在不借助并发框架情况下，实现生产、消费协作。 消费者启动后，使用yield将执行权限交给生产者，等待其发送数据后激活处理。 如有多个消费者，或数据处理时间较长，依然建议使用专业并发方案 >>> def consumer(): ... while True: ... v = yield ... print(f\"consume: {v}\") ... >>> def producer(c): ... for i in range(10, 13): ... c.send(i) ... >>> c = consumer() # 创建消费者 >>> c.send(None) # 启动消费者 >>> producer(c) # 生产者发送数据 consume: 10 consume: 11 consume: 12 >>> c.close() # 关闭生产者 消除回调 回调函数是常见异步接口设计方式。调用者在发起请求后，不再阻塞等待结果返回，而改由异步服务调用预先注册的函数来完成后续处理。 设计一个简单异步服务示例，然后尝试用生成器消除回调函数。 >>> import threading >>> import time >>> def target(request, callback): ... s = time.time() ... request() # 调用请求函数 ... time.sleep(2) # 模拟阻塞 ... callback(f\"done: {time.time() - s}\") # 调用回调函数，传入结果 ... >>> def service(request, callback): ... threading.Thread(target= target, args=(request, callback)).start() ... >>> def request(): # 任务请求模拟 ... print(\"start\") ... >>> def callback(x): # 任务结束通知 ... print(x) >>> service(request, callback) start done: 2.001331090927124 接下来，用生成器函数替代上面的2个函数，用yield分隔请求和返回代码，以便服务可接入其中，同时，修改服务框架，以生成器方式来调用任务。 >>> import threading >>> import time >>> def request(): ... print(\"start\") ... x = yield ... print(x) ... >>> def target(fn): ... try: ... s = time.time() ... g = fn() # 调用目标生成器函数 ... g.send(None) # 启动，开始执行请求代码 ... time.sleep(2) ... g.send(f\"done: {time.time() - s}\") # 阻塞结束后，结果返回任务 ... except StopIteration: # 目标结束，拦截异常 ... pass ... >>> def service(fn): ... threading.Thread(target=target, args=(fn,)).start() ... >>> service(request) start >>> print(\"do something\") # 发请求后，并未阻塞 do something done: 2.001655340194702 协程 协程以协作调度方式，在单个线程上切换执行并发任务。配合异步接口，可将I/O阻塞时间来执行更多任务。由于在用户空间实现，因此被称为用户线程。 >>> def sched(*tasks): ... tasks = list(map(lambda t: t(), tasks)) #调用所有任务函数，生成器列表 ... while tasks: #循环调用任务 ... try: ... t = tasks.pop(0) # 从列表头部弹出任务 ... t.send(None) # 开始执行该任务 ... tasks.append(t) # 如该任务没有结束，则放回列表尾部 ... except StopIteration: # 该任务结束，丢弃 ... pass >>> def task(id, n, m): # 模拟任务模板 ... for i in range(n, m): ... print(f\"{id}: {i}\") ... yield # 主动调度 ... >>> t1 = partial(task, 1, 10, 13) >>> t2 = partial(task, 2, 30, 33) >>> sched(t1, t2) 1: 10 2: 30 1: 11 2: 31 1: 12 2: 32 函数式编程 函数式编程以计算表达式来替代命令式语句，强调逐级结果推导，而非执行过程。 函数式编程要求函数为第一类型，可作为参数和返回值传递。需要时，可用闭包构成带有上下文状态的逻辑返回。其通常不使用独立变量，所有状态以参数传递，用嵌套或链式调用代替过程语句。最好没有外部依赖的纯函数，且参数不可变，仅将结果带入下一次运算。 命令式： x = a + b y = x * 2 函数式: mul(add(a, b), 3) add(a, b).mul(2) 函数式编程三大特征：第一类型函数，不可变数据，尾递归优化。 函数式编程只是一种编程范式 迭代 以迭代器方式，用指定函数处理数据源。相比推导式，它能从多个数据源中平行接收参数，直到最短数据源迭代完成。 >>> x = map(lambda a, b: (a, b), [1 ,2 ,3], \"abcd\") >>> list(x) # 将迭代器对象转换为列表 [(1, 'a'), (2, 'b'), (3, 'c')] 聚合 平行从多个数据源接收参数，聚合成元组，直到最短数据源迭代结束。 >>> x = zip([1,2,3], \"abcd\", (1.1,1.2)) >>> list(x) [(1, 'a', 1.1), (2, 'b', 1.2)] 如构造字典。都以最短数据源，如以最长数据源，则用itertools.zip_longest。 >>> kv = zip(\"abcd\", range(100, 200)) >>> dict(kv) {'a': 100, 'b': 101, 'c': 102, 'd': 103} 累积 迭代数据源，将结果带入下次计算，适合完成统计或过滤操作。 >>> import functools >>> def calc(ret, x): ... print(f\"ret = {ret}, x = {x}\") ... return ret + x ... >>> functools.reduce(calc, [1, 2, 3]) #没有初始化值，直接将第一数据当结果 ret = 1, x = 2 ret = 3, x = 3 6 >>> functools.reduce(calc, [1, 2, 3], 100) # 要对第一数据和初始化值进行计算 ret = 100, x = 1 ret = 101, x = 2 ret = 103, x = 3 106 过滤 使用指定函数对数据进行迭代过滤。 函数返回的布尔值决定数据的去留。参数为None时相当于bool函数，移除所有False元素。 >>> x = filter(lambda n: n % 2 ==0, range(10)) >>> list(x) [0, 2, 4, 6, 8] >>> list(filter(None, [0, 1, \"\", \"a\", [], (1,)])) [1, 'a', (1,)] 判断 判断在一系列数据中，全部或某个元素为真值。 >>> all([1, \"a\", (1,2)]) True >>> any([0,\"\",(1,2)]) True >>> 迭代会短路，比如all遇到第一个False，就立即终止。 >>> def a(): ... print('a') ... return True ... >>> def b(): ... print('b') ... return False ... >>> def c(): ... print('c') ... return True ... >>> all(map(lambda m: m(), (a, b, c))) a b False >>> any(map(lambda m: m(), (a, b, c))) a True 标准库itertools拥有大量针对迭代器的操作函数，推荐使用。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/module.html":{"url":"basic/module.html","title":"模块","keywords":"","body":"模块 定义 模块是顶层代码组织单元，其提供大粒度封装和复用。 通常每个模块对应一个源码文件。其中定义的变量、函数、类型等，都属于其私有成员。 模块在首次导入时，被编译成字节码。随后解释器开始创建模块实例，执行初始化语句，构建内部成员。模块不仅是代码组织形式，还是运行期对象，其为成员提供全局名字空间。 无论被导入多少次，每个模块在整个解释器进程内部仅有一个实例存在。重复导入只是引用已存在的实例，并不会再次执行初始化过程。 demo.py x = 1234 def hello(): pass class User: pass >>> import demo >>> import types >>> isinstance(demo, types.ModuleType) True 初始化 初始化过程就是将模块里的代码按序执行一面。初始化过程很简单：普通语句直接执行，类似于def、class等则创建函数和类型对象。最终这些成员都保存在模块的全局名字空间内。 >>> import demo >>> vars(demo) {'__name__': 'demo',origin='D:\\\\workspace\\\\Python\\\\study_notes\\\\demo.py'), '__file__': 'D:\\\\workspace\\\\Python\\\\study_notes\\\\demo.py', '__cached__': 'D:\\\\workspace\\\\Python\\\\study_notes\\\\__pycache__\\\\demo.cpython-37.pyc', ... , 'x': 1234, 'hello': , 'User': } 示例中全局变量x，初始化过程为其赋予一个初始值。以后执行中，它可能改变。如每次都初始化，则可能会将改变的状态丢失。所以，重复导入只是引用，不会再次执行。 名字空间 模块的全局名字空间对应__dict__属性，其中内部不能被直接访问，且不会别dir输出。 >>> vars(demo) is demo.__dict__ True 函数vars返回目标dict属性。参数为空时，类似于locals返回当前名字空间。而dir则返回目标，或当前名字空间可访问的名字列表。 当def创建函数对象时，会将所有模块的名字空间作为构造参数。这意味着，无论后续将该函数传递到何处，还是\"绑定\"给其他模块，都不能改变函数内部globals总是返回出生地的名字空间。 demo.py >>> import demo >>> demo.test() is vars(demo) # 任何地方调用，函数依然返回出生地名字空间 True >>> import types >>> m = types.ModuleType(\"abc\") >>> m.test = demo.test >>> m.test() is vars(demo) # 即使绑定给其他模块，依然无法改变这点 True >>> m.test.__module__ 'demo' >>> dir(m) ['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'test'] 名字 可通过__name__、__file__获取所在模块信息。或者，利用__module__属性返回类型、函数等对象的的定义模块名称。 >>> x = demo.test >>> x.__module__ 'demo' 建议使用inspect.getmodule获取目标对象定义模块引用。 正常情况下，模块名字对应原文件名。但有个例外，就是当模块作为程序入口时，会被赋予\"\\\\main__\"名字。 demo.py print(__name__) $ python demo.py __main__ $ python -c \"import demo\" demo 如此，只需要编写如下语句，则可让其自动适应身份变化。 def main(): test() if __name__ == \"__main\": main() 创建语句def并不会执行main函数，只有作为入口时才会进入流程。如果作为普通模块导入，则因名字不匹配而被忽略。另外，不建议将main函数内容直接放在if语句内，因为这回直接操作全局名字空间，可能引发不必要的错误。 导入 按LEGB规则，除包含内置函数的__builtins__模块外，所有名字搜索都不能超出当前模块。所有任何外部目标，都必须提前导入当前名字空间，否则无法访问。 导入步骤： 搜索目标模块文件； 按需编译目标模块； 创建模块实例，执行初始化； 将模块实例保存到全局列表； 在当前名字空间建立引用。 模块实例一旦创建，就保存在sys.modules，后续导入直接引用。 内置模块__builtins__由解释器自动导入。 >>> for i in range(3): ... import sys #重复导入，不会新建实例。 ... print(id(sys)) ... 2709757489048 2709757489048 2709757489048 搜索 导入所使用的模块名不能包含路径信息，这需要系统提供搜索方式和匹配规则。其中搜索路径，由解释器在启动时，按优先级整理到sys.path列表中。 搜索路径列表： 程序根目录； 环境变量(PYTHONPATH)设定的路径列表； 标准库目录； 第三方扩展库等附加路径(site-specific)。 附加路径由site模块添加，在解释器启动时自动执行(可用参数-S禁用)。除系统site-packages外，还包括用户相关目录。 D:\\>python -c \"import sys, pprint; pprint.pprint(sys.path)\" ['', # 根目录 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python37.zip', # 标准库 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\DLLs', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37', 'C:\\\\Users\\\\user\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site-packages', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages', # 系统扩展库目录 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages\\\\win32', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages\\\\win32\\\\lib', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages\\\\Pythonwin'] D:\\>python -S -c \"import sys, pprint; pprint.pprint(sys.path)\" # 禁用site, 缺少site-packages ['', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python37.zip', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\DLLs', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37'] 另可设置环境变量PYTHONPATH，然后请注意优先级。 虽可在运行期向sys.path添加搜索路径。但对扩展库而言，更简便方式就是路径配置文件。将所有要添加的路径按行保存在.pth文本文件内，并放在site-packages等目录中，剩下的就由site完成。 site-packages/demo.pth # comment # 注释 D://workspace//Python # 绝对路径 mypkg # 相对路径 D:\\>python -m site sys.path = [ 'D:\\\\', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python37.zip', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\DLLs', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37', 'C:\\\\Users\\\\user\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site-packages', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages', # 系统扩展库目录 'D:\\\\workspace\\\\Python', # 路径配置添加目录 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages\\\\mypkg', # 路径配置添加目录 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages\\\\win32', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages\\\\win32\\\\lib', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages\\\\Pythonwin', ] USER_BASE: 'C:\\\\Users\\\\user\\\\AppData\\\\Roaming\\\\Python' (exists) USER_SITE: 'C:\\\\Users\\\\user\\\\AppData\\\\Roaming\\\\Python\\\\Python37\\\\site-packages' (exists) ENABLE_USER_SITE: True 注意：site会过滤掉配置重复的目录或文件，以及不存在的路径。 整理好搜索路径列表后，就需要进一步匹配模块文件名。问题是，语言规范并未定义不同扩展名的同名模块匹配次序，所以安全起见，不要在同一路径放同名模块。 源码或字节码文件(.py、.pyc)； 包目录名； 其他语言编写的扩展模块(.dll、.so等)。 编译 确定模块文件路径后，编译器优先选择已编译的字节码文件，这有助提升载入性能。 D:\\workspace\\Python\\study_notes>python -c \"import demo\" D:\\workspace\\Python\\study_notes>dir __pycache__ Volume in drive D is DATA Volume Serial Number is 94EF-A3E1 Directory of D:\\workspace\\Python\\study_notes\\__pycache__ 2019/06/04 17:10 . 2019/06/04 17:10 .. 2019/06/04 17:10 261 demo.cpython-37.pyc 1 File(s) 261 bytes 2 Dir(s) 139,498,631,168 bytes free D:\\workspace\\Python\\study_notes>python -OO -c \"import demo\" D:\\workspace\\Python\\study_notes>dir __pycache__ Volume in drive D is DATA Volume Serial Number is 94EF-A3E1 Directory of D:\\workspace\\Python\\study_notes\\__pycache__ 2019/06/04 17:11 . 2019/06/04 17:11 .. 2019/06/04 17:11 261 demo.cpython-37.opt-2.pyc 2019/06/04 17:10 261 demo.cpython-37.pyc 2 File(s) 522 bytes 2 Dir(s) 139,498,631,168 bytes free 无源码部署 运行时，源码文件不是必需的。解释器需要的字节码及相关元数据，编译后存储在内存或保存在字节码文件中。部署时，可移除源码，改为直接部署字节码文件。 不能直接使用__pycache__下的文件，它的文件命名方式不适合作为直接部署使用。缓存文件很容易被dis反编译，并不能有效保护代码安全。 main.py import demo demo.hello() demo.py def hello(): print(\"hello world!\") 使用compileall编译所有源文件。 $ python -m compileall -b -l *.py # 编译所有文件（以源文件名保存，不含目录) $ mkdir release $ mv *.pyc release/ # 将生成的.pyc文件转移到独立目录 $ cd release/ $ ls demo.pyc main.pyc $ python main.pyc # 使用解释器执行 hello world! 引用 可同时引入多个模块，或模块中的多个成员，当名字发生冲突时，可用as命名别名。 In [1]: import sys, inspect as reflect In [2]: from string import ascii_letters as letters, ascii_lowercase as lowercase In [3]: %whos # Ipython命令，查看环境变量信息 Variable Type Data/Info ------------------------------- letters str abcdefghijklmnopqrstuvwxyBCDEFGHIJKLMNOPQRSTUVWXYZ lowercase str abcdefghijklmnopqrstuvwxyz reflect module thon37\\\\lib\\\\inspect.py'> sys module 别名仅在当前名字空间有效，并不影响被导入的模块或其成员。别名还可用来缩写处理。如导入成员过多，可用括号或续行符分成多行。 导入语句放在文件头部，以“标准库、扩展库、当前程序模块”分别排列。 >>> import sys # 标准库 >>> import inspect >>> import psutil # 扩展库 >>> import numpy >>> import db # 应用程序模块 >>> import demo 成员导入时，其名字和其他模块或当前模块成员冲突可能性很大。且对模块重新载入有影响，故不建议在模块级别使用。以星号导入目标模块全部成员的行为，更是被规范所禁止。 >>> from sys import version >>> print(version) 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] >>> version = \"ver: 1.0\" # 在当前名字空间内被覆盖，同一名字仅一个关联 >>> print(version) ver: 1.0 在函数内部，因其名字空间范围小，且生命周期短，故影响较小。这样，使用成员导入可减少代码，且能提升性能。Python3在函数内不允许用星号导入。 >>> def test(): ... from sys import version ... print(version) ... >>> test() 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] 下面比较下模块导入和成员导入指令的差异性： >>> def a(): ... import sys ... print(sys.version) ... >>> def b(): ... from sys import version ... print(version) ... >>> import dis >>> dis.dis(a) 2 0 LOAD_CONST 1 (0) 2 LOAD_CONST 0 (None) 4 IMPORT_NAME 0 (sys) 6 STORE_FAST 0 (sys) 3 8 LOAD_GLOBAL 1 (print) 10 LOAD_FAST 0 (sys) # 需要两条指令引用version 12 LOAD_ATTR 2 (version) 14 CALL_FUNCTION 1 16 POP_TOP 18 LOAD_CONST 0 (None) 20 RETURN_VALUE >>> dis.dis(b) 2 0 LOAD_CONST 1 (0) 2 LOAD_CONST 2 (('version',)) 4 IMPORT_NAME 0 (sys) 6 IMPORT_FROM 1 (version) 8 STORE_FAST 0 (version) 10 POP_TOP 3 12 LOAD_GLOBAL 2 (print) 14 LOAD_FAST 0 (version) # 单条执行，且是FAST 16 CALL_FUNCTION 1 18 POP_TOP 20 LOAD_CONST 0 (None) 22 RETURN_VALUE 如多次调用，对比更明显。 In [1]: def a(): ...: import sys ...: for i in range(100): ...: s = sys.version ...: return s ...: In [2]: def b(): ...: from sys import version ...: for i in range(100): ...: s = version ...: return s In [4]: %timeit a() 4.08 µs ± 53.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) In [7]: %timeit b() 2.74 µs ± 80.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each) 导出列表 星号导入是将目标模块名字空间内的所有成员全部导入，这肯定有用不到的东西。但无法阻止用户使用星号。结果就是导致调用方名字空间被污染。 demo.py import sys x = 1234 def hello(): print(\"hello world!\") main.py from demo import * print(dir()) $ python main.py # demo的成员 以及导入的sys，都进入调用者main的名字空间 ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'hello', 'sys', 'x'] 简单做法就是模块成员私有化，也就是名字添加下划线前缀。私有成员不会被星号导入。 demo.py import sys as _sys # 私有别名？ _x = 1234 # 私有成员 def hello(): print(\"hello world!\") $ python main.py ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'hello'] 这样不太方便也不很美观，正确做法就是模块添加__all__声明，明确指定那些可以被星号导入到成员名字列表。为空则表示不会导入任何成员。 demo.py __all__ = [\"hello\"] import sys x = 1234 def hello(): pass $ python main.py # 仅 __all__指定成员被星号导入 ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'hello'] 无论私有成员，还是_all\\_导出列表，都不影响显示成员导入。 demo.py __all__ = [] import sys _x = 1234 def hello(): pass main.py from demo import _x, hello print(dir()) $ python main.py # 仅 __all__指定成员被星号导入 ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_x', 'hello'] 动态导入 使用import是明确知道目标模块名字。但有时，只有运行期才能动态获取，这需要以其他方式导入。 方法一：使用exec 动态执行，随后从sys.modules中获取模块实例。 >>> def test(name): ... exec(f\"import {name}\") ... m = sys.modules[name] ... print(m) >>> test(\"inspect\") 方法二：使用importlib库。 >>> import importlib >>> def test(name): ... m = importlib.import_module(name) ... print(m) ... >>> test(\"inspect\") 重新载入 模块一旦导入，解释器不关心源文件是否被修改。但有时需要在不重启进程情况下，对某些模块实现热更新。 既然模块实例保存在sys.modules列表，可否移除实例引用，然后重新导入呢？ demo.py x = 1234 In [1]: import demo In [2]: demo.x Out[2]: 999 In [3]: import sys In [4]: del sys.modules[\"demo\"] # 从sys.modules移除，使其回收 # 修改源码，将999改为888，然后保存 In [5]: import demo # 重新导入 In [6]: demo.x # 更改生效 Out[6]: 888 In [7]: m = demo # 另一引用 In [8]: m.x Out[8]: 888 In [9]: del sys.modules[\"demo\"] # 移除 # 修改源码，将888改为777，然后保存 In [10]: import demo # 再次导入 In [11]: demo.x Out[11]: 777 In [12]: m.x # 另一引用m没有影响。热更新失败 Out[12]: 888 In [13]: m is demo # 不同模块实例 Out[13]: False 由于m的存在，导致旧demo模块实例不会回收。这样的话，更新后就各自引用不同模块实例。 标准库提供了importlib.reload。 In [1]: import importlib In [2]: import demo In [3]: m = demo # 另一引用 In [4]: m.x Out[4]: 777 #修改源码，将777改为666，然后保存 In [5]: importlib.reload(demo) # 重新载入模块 Out[5]: In [6]: demo.x # 热更新成功 Out[6]: 666 In [7]: m.x # 其他引用也同步更新 Out[7]: 666 In [8]: demo is m # 引用同一模块实例 Out[8]: True 但reload只对模块引用有效，对成员引用无法更新，因为reload不会递归修改成员。 因此，应避免直接引用其他模块成员，而通过模块直接访问。当然，在函数内部，成员引用生命周期短，对热更新影响有限。 另外，模块重载会重新初始化，会导致状态丢失，并引发其他错误，请慎重对待。 包 模块用来组织代码，包就是用来组织模块。 将多个源文件放在同一目录，就构成了包。包能隐藏内部文件的组织结构，而仅暴露必要的用户接口，毕竟不是所有模块都对外提供服务。 │ demo.py │ main.py │ └───lib demo.py >>> import lib >>> lib >>> vars(lib) {'__name__': 'lib', '__doc__': None, '__package__': 'lib', '__file__': None, '__path__': _NamespacePath(['D:\\\\workspace\\\\Python\\\\study_notes\\\\lib', 'C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages\\\\win32\\\\lib']),...} 从包名字空间看，仅导入包并不能直接访问其内部模块，须显示导入。 >>> import lib.demo >>> lib.demo.__package__ 'lib' >>> lib.demo.__name__ 'lib.demo' 初始化 包是另类的模块实例，其对应源文件__init__.py。虽在python3不再必须，但可用来执行初始化操作，比如提供对外接口，解除用户对内部模块的直接依赖。 │ demo.py │ main.py │ └───lib │ demo.py │ __init__.py >>> import lib >>> lib.__file__ 'D:\\\\workspace\\\\Python\\\\study_notes\\\\lib\\\\__init__.py' 初始化文件在包或其内部模块首次导入时自动执行，且仅执行一次。 __init__.py print(\"init\") demo.py print(\"demo\") >>> import lib.demo init demo >>> import lib 注意：重载包内部模块，不会再次执行初始化文件，但重载包则会。 还可在包内创建__main__.py文件，作为直接执行时的入口。 _main\\_.py print(\"main\") $ python -m lib # 以包方式运行，自动执行初始化文件 init # 先导入包，后执行__main__.py main $ python lib # 以普通方式运行，对应__main__入口模块 main # 不会自动执行初始化文件，除非显示导入__init__ $ python -c \"import lib\" #__main__.py对普通导入没影响 init 隐藏结构 既然初始化文件构成了包名字空间，那么只要将要公开给用户的模块或成员导入过来，即可解除用户对具体模块的依赖。 demo.py def hello(): print(\"Hello, World!\") _init\\_.py from .demo import hello >>> import lib >>> lib.hello() Hello, World! 这样，用户只依赖包和初始化文件中导入的特定成员。无论怎么重构代码和重新组织模块文件，都不影响用户调用接口。即使将公开成员升级到新版本，也可用别名方式映射到原名字，实现多版本的单一名称。 demo.py def hello(): print(\"Hello, World!\") def hello2(): from sys import version print(version) hello() _init\\_.py from .demo import hello2 as hello 还可将整个包压缩成ZIP文件分发。 lib.v1.zip # 任意文件名，可添加版本等信息，然后压缩，并可将源目录命名 │ └───lib # 必须包含包目录 │ demo.py │ __init__.py 使用前，将.zip文件路径加入到sys.path，这可动态添加或使用路径配置文件。 >>> import sys >>> sys.path.append(\"./lib.v1.zip\") >>> import lib >>> lib.__file__ '.\\\\lib.v1.zip\\\\lib\\\\__init__.py' 因解释器不会向.zip中写入缓存文件，故建议用.pyc打包，加快导入速度。 也可将应用程序进行打包，不过须在根目录中放置_main\\_.py作为执行入口 app.zip │ └───__main__.py │ └───lib # 必须包含包目录 │ demo.py │ __init__.py _main\\_.py print(\"main\") import lib lib.hello() $ zip -r -o app.zip __main__.py lib $ python app.zip main Hello, World! 导出列表 同样可在初始化文件中添加__all__星号导出成员列表。除当前文件成员外，还可指定要导出的模块名字。 _init\\_.py __all__ = [\"x\", \"demo\"] # 可被星号导出的模块和本地成员 x = 100 y = 200 >>> from lib import * >>> dir() [\"demo\", \"x\", ...] 相对导入 通常将包放置在应用程序根目录，或其他系统目录。但是，搜索路径列表并不包括包目录自身，就导致在包内访问同级模块时，发生找不到文件的状况。 _init\\_.py import demo demo.hello() demo.py def hello(): print(\"Hello, World!\") >>> import lib Traceback (most recent call last): File \"\", line 1, in File \"D:\\workspace\\Python\\study_notes\\lib\\__init__.py\", line 1, in import demo ModuleNotFoundError: No module named 'demo' 就算在包内导入，import语句也严格按照搜索路径列表查找。它会搜索应用程序根目录，但不检查包目录。 修改_init\\_.py import lib.demo lib.demo.hello() 在包内使用全名绝对路径不够友好，为此，Python3引入了相对路径概念，以点前缀表达当前或上级包。 / | +---lib | | demo.py | | __init__.py | | __main__.py | | | +---sub | | test.py lib/sub/test.py from ..demo import hello # 从上级包的demo模块导入hello lib/__init__.py from . import demo # 从当前包导入demo模块 from .demo import hello # 从当前包的demo模块导入hello from .sub import test # 从当前包的sub子包导入test模块 相对导入只能用于from子句，可导入模块或成员 单个.表示当前包，..表示上级包，...表示更上以及的包，依次类推。 相对路径解除了对报名的依赖，其还可用来解除名字冲突。 比如导入string时，如使用相对导入则明确表示选择包内(或上级)模块，否则就是选择标准库的同名模块。 优先级 同名除让解释器困扰外，也给代码维护带来了潜在风险。当相同名字的包或模块出现在同一路径下，那么解释器按如下顺序匹配。 如包有初始化文件(包括空文件)，则导入包； 没有初始化文件，则.py或.pyc模块优先 图：1559724201028 拆分 当包内模块文件过多时，可建立子包分组维护，但这需要修改内部的相对导入路径。还有一个方法，同样是将文件分散到多个子目录下，但它们依然属于同一级别的包成员。 先将原本放在同一目录下的模块文件分别转移到各自的分组子目录中。 为让它们继续以包成员的形式存在，须在包__init__.py中修改__path__属性。 包_path\\_的作用类似sys.path，实现包内搜索路径列表，并进行相同匹配规则。在该搜索列表中默认为包的全路径，只需将子目录的全路径添加进去即可。因子目录中的各模块依然属于原包级别，故模块间的相对导入无须修改。 图：1559726056262 __init__.py from . import hello from . import demo import os.path __path__.extend(os.path.join(__path__[0], d) for d in (\"a\", \"b\")) print(__path__) print(demo.__file__) print(hello.__file__) >>> import lib ['D:\\\\workspace\\\\Python\\\\study_notes\\\\lib', 'D:\\\\workspace\\\\Python\\\\study_notes\\\\lib\\\\a', 'D:\\\\workspace\\\\Python\\\\study_notes\\\\lib\\\\b'] D:\\workspace\\Python\\study_notes\\lib\\demo.py D:\\workspace\\Python\\study_notes\\lib\\hello.py © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/class.html":{"url":"basic/class.html","title":"类","keywords":"","body":"类 面向对象编程是最流行的编写软件方法之一。在面向对象编程中，基于类来创建对象就是很通用的方法。根据类来创建对象被称为实例化。 定义 类封装一组相关数据，使之成为一个整体，并使用方法持续展示和维护。与函数类似，类也是一种小粒度复用单位，其行为特征更复杂。函数具有单一入口和出口，可完成一次计算过程，而类从构造开始就面临多个方法。按不同次序调用会有不同结果。 类存在两种关系：继承 和 组合。 类与模块作为复合结构由相似之处，但不同之处在于： 类可生成多个实例 类可被继承和扩展 类实例的生命周期可控 类支持运算符，可按需重载 创建和使用类 使用类可模拟任何东西。比如简单类Dog，如下： class Dog(): def __init__(self, name, age): self.name = name self.age = age def sit(self): print(slef.name.title()+' is now sitting.') def roll_over(self): print(self.name.title()+\"rolled over!\") 在Python中，类一般定义时名称都是首字母大写的。类定义括号为空，表示从空白创建这个类。 方法__init__()时一个特殊方法，在类创建新实例时，会自动运行它，开头和末尾有两个下划线，这是一种约定，以便与自己定义的普通方法发生名称上的冲突。 在定义方法时，形参self必不可少，还必须在其他形参前面。这是因为Python在调用方法时会自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能访问类中的属性和方法。所以每个类所定义的方法第一个参数都是self。 以上是创建类，那么怎么调用呢？也就是需要根据类创建实例，再通过实例来调用相应的方法。比如: my_dog = Dog('willie', 6) print(\"My dog's name is \"+my_dog.name.title()+\"!\") print(\"My dog's is \"+str(my_dog.age)+\" years old.\") my_dog.sit() my_dig.roll_over() 上面演示了怎么通过实例来调用对象的属性与方法。那怎么修改属性呢？第一是直接修改，第二是通过方法来修改。比如： my_dog.age = 7 通过方法就需要在类中定义方法。接上面定义的类（部分代码省略）： def setAge(self, age): self.age = age my_dog.setAge(7) 虽然可通过上面方法来控制类修改类中的属性，但为确保安全，还是要进行必要的基本检测，以保障类的安全。 关键字class同样是运行期指令，用以完成类型对象的创建。 >>> def test(): ... class X: ... data = 100 ... def get(self): return self.data ... >>> import dis >>> dis.dis(test) 2 0 LOAD_BUILD_CLASS 2 LOAD_CONST 1 () # test.__code__.co_consts[1] 4 LOAD_CONST 2 ('X') 6 MAKE_FUNCTION 0 # 创建X函数 8 LOAD_CONST 2 ('X') 10 CALL_FUNCTION 2 # 调用__build_class__哈数 12 STORE_FAST 0 (X) 14 LOAD_CONST 0 (None) 16 RETURN_VALUE ... 从上反编译来看，先创建X函数，其内容是属性设置和方法创建。随后，该函数被当做参数传递给builtins.__buildclass\\_调用，这里其实就是元类执行所在。 在_build_class\\_调用X时，会提供一个字典作为其推栈帧的名字空间，用于保存类型成员。完成后，将该字典连同名字和基类一起传递给元类，最终生成目标类型对象。 类型和实例 如果类型在模块中定义，那么其生命周期与模块等同。如果其放在函数内，那么每次都是新建，即使名字和内容形同，也属于不同类型。 >>> def test(): ... class X: pass ... return X() ... >>> a, b = test(), test() >>> a.__class__ is b.__class__ False 函数内定义的类型对象，在所有实例死亡后，会被垃圾回收 类型对象除用来创建实例外，也为所有实例定义了基本操作接口，其负责管理整个家族的可共享收据和行为模板。而实例只保存私有特征，其在内部引用从所属类型或其他祖先类查找所需的方法，用来驱动和展现个体面貌。 类型所创建的多个实例之间，除家庭归属外，并无直接关系。无论从诞生到消亡，还是私有数据变更，都不影响类型或其他兄弟姐妹。 名字空间 类型有自己的名字空间，存储当前类型定义的字段和方法。这其中并不包括所继承的祖先成员，其同样以引用关联祖先类型，无须复制到本地。 >>> class A: ... a = 100 # 类字段 ... def __init__(self, x): # 实例初始化方法 ... self.x = x # 实例字段 ... def get_x(self): # 实例方法 ... return self.x >>> class B(A): # 继承自A ... b = \"hello\" ... def __init__(self, x, y): ... super().__init__(x) # 调用父类的初始化方法 ... self.y = y ... def get_y(self): ... return self.y >>> o = B(1, 2) 实例会存储所有继承层次的实例字段，因为这些都属于其私有数据。方法算是函数辩题，其本身无状态，所以可共享。即便继承，也有其私有特征。也因为这些私有数据驱动，才能让方法展现不同结果来。 >>> A.__dict__ # 类型名字空间返回mappingproxy只读视图，不可直接修改。 mappingproxy({'__module__': '__main__', 'a': 100, '__init__': , 'get_x': , '__dict__': , '__weakref__': , '__doc__': None}) >>> B.__dict__ mappingproxy({'__module__': '__main__', 'b': 'hello', '__init__': , 'get_y': , '__doc__': None}) >>> o.__dict__ # 实例 名字空间是普通字段，可直接修改。 {'x': 1, 'y': 2} >>> dir(o) # 函数dir搜索所有可访问成员名字，vars直接返回__dict__属性 ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'a', 'b', 'get_x', 'get_y', 'x', 'y'] >>> vars(o) {'x': 1, 'y': 2} 当通过实例或类型访问某个成员时，会从当前对象开始，依次由近到远向祖先类查找。如此的好处就是祖先新增功能可直接遗传给所有后代。 在继承层次的不同名字空间中允许有同名成员，并按顺序优先命中。 成员查找规则和LEGB不同。前者基于继承体系，后者基于执行作用域。 >>> x = 100 >>> class A: ... def __init__(self, x): ... self.x =x ... def test(self): ... print(x) # LEGB ... print(self.x) # 明确以self指定搜索目标 ... >>> o = A(\"abc\") >>> o.test() 100 abc 类型创建时，class在内部以函数方式执行。接收类型名字空间字典作为堆栈帧执行的名字空间。这样，成员定义作用域内的locals实际指向了class.__dict__（可读写）。从语法上，class是类型定义，而非函数定义，这与内部执行方式无关，因此class不构成E/enclosing作用域 >>> def enclosing(): ... a = \"enclosing.a\" ... class A: ... a = \"A.a\" # L ==> A.__dict__ ... def test(self): ... print(\"E.a=\", a) # E ==> enclosing.a ... print(\"A.locals =\", locals()) # L ==> A.__dict__ ... print(\"A.a =\", a) # L ==> A.__dict__ ... A().test() ... >>> enclosing() A.locals = {'__module__': '__main__', '__qualname__': 'enclosing..A', 'a': 'A.a', 'test': .A.test at 0x0000015740E02AE8>} A.a = A.a E.a= enclosing.a 字段 按所处名字空间不同，将字段分为类型字段和实例字段两类。官方文档将成员统称为Attribute。 类型字段在class语句块内直接定义，而实例字段必须通过实例引用(self)赋值定义。仅从执行方式来看，无论实例方法存在于哪级类型，其隐式参数self总指向当前调用实例。那么通过它创建的字段，也必然存在于该实例的名字空间内。 >>> class A: ... def test(self): # self总是引用当前实例，这与继承层次无关 ... print(self) ... self.x = 100 # 向当前实例字段赋值 ... >>> class B(A): ... pass ... >>> o = B() >>> hex(id(o)) '0x15740dfccf8' >>> o.test() # 对比实例id 站在语法和设计角度来看，实例字段是所有类型的组成部分，与该类型的相关方法关联。所以，依然称其为某某类型的实例字段。 字段赋值 可使用赋值语句为类型或实例添加新的字段。 >>> class X: pass ... >>> X.a = 100 # 新增类型字段 >>> vars(X) mappingproxy({'__module__': '__main__', '__dict__': , '__weakref__': , '__doc__': None, 'a': 100}) >>> o = X() >>> o.b = 200 # 新增实例字段 >>> vars(o) {'b': 200} 可一旦以子类或实例重新赋值，就将会在其名字空间建立同名字段，并会遮蔽原字段。这与“赋值总是在当前名字空间建立关联”规则一致。 >>> class X: pass ... >>> o = X() >>> X.data = 100 >>> o.data # 按搜索规则，命中X.data 100 >>> o.data = 200 # 在o名字空间新建data实例字段 >>> o.data # 按搜索顺序，命中o.data 200 >>> vars(o) {'data': 200} >>> X.data # 不影响原类型字段 100 >>> vars(X) mappingproxy({'__module__': '__main__', '__dict__': , '__weakref__': , '__doc__': None, 'data': 100}) 删除操作仅针对当前名字空间，而不会按搜索顺序查找类型或基类。 >>> class X: pass ... >>> X.data = 100 >>> o = X() >>> del o.data # 当前实例名字空间并没有data成员 Traceback (most recent call last): File \"\", line 1, in AttributeError: data 成员访问总是按搜索规则进行，这与普通变量的静态作用域不同。 >>> class X: ... data = \"X.data\" ... >>> def test(): ... o = X() ... print(o.data) # 找到 X.data ... o.data = \"o.data\" # 新增o.data ... print(o.data) # 找到o.data ... del o.data # 删除o.data ... print(o.data) # 找到X.data ... >>> test() X.data o.data X.data 私有字段 将私有字段暴露给用户是很危险的。因为无论是修改还是删除都无法被截获，因此可能引发意外错误。因为没有严格意义上访问权限设置，所以最好将他们隐藏起来。 如成员名字以上下划线开头，但没有以上下划线结尾，那么编译器会自动将其重命名。 >>> class X: ... __table = \"user\" # 类型成员 ... def __init__(self, name): ... self.__name = name # 实例成员 ... def get_name(self): ... return self.__name ... >>> vars(X) mappingproxy({'__module__': '__main__', '_X__table': 'user', '__init__': , 'get_name': , '__dict__': , '__weakref__': , '__doc__': None}) >>> vars(X(\"user1\")) {'_X__name': 'user1'} 所谓重命名，就是被编译器附加了类型名称前缀。而且这种方式让继承类也无法访问。 重命名机制总是针对当前类型，继承类型无法访问重命名后的基类成员。可将双下划线前缀改为单下划线，虽不能自动重命名，但提示作用依旧。 >>> class A: ... __name = \"user\" ... >>> class B(A): ... def test(self): ... print(self.__name) # 被当做当前类型的私有字段重命名：_B__name ... >>> B().test() AttributeError: 'B' object has no attribute '_B__name' 相关函数 以下为几个与类成员相关的内置函数。 >>> class A: ... data = \"A.data\" ... >>> class B(A): ... pass ... >>> hasattr(B(), \"data\") # 按搜索规则查找整个继承层次 True >>> getattr(B(), \"data\") # 相当于B().data,同样是按搜索规则进行 'A.data' >>> getattr(B(), \"name\", \"abc\") # 返回默认值 'abc' >>> o = B() >>> o.data 'A.data' >>> setattr(o, \"data\", \"o.data\") # 等同于o.data ='o.data',针对当前名字空间 >>> o.data 'o.data' >>> o = B() >>> delattr(o, \"data\") # 等同于del o.data,针对当前名字空间 AttributeError: data 它们是相关语句的函数版本，可接收动态成员名称，还能用于lambda函数。 >>> (lambda: getattr(B(), \"data\"))() 'A.data' 属性 对私有字段进行重命名保护，那公开字段该如何处理？ 问题的核心是访问拦截，必须由内部逻辑决定如何返回结果。而属性(property)机制就是将读、写和删除操作映射到指定的方法调用上，从而实现操作控制。 >>> class X: ... def __init__(self, name): ... self.__name = name ... @property # 读 ... def name(self): ... return self.__name ... @name.setter # 写(注意语法格式) ... def name(self, value): ... self.__name = value ... @name.deleter # 删除 ... def name(self): ... raise AttributeError(\"can't delete attribute\") ... >>> o = X(\"user1\") >>> o.name 'user1' >>> o.name = \"abc\" >>> o.name 'abc' >>> del o.name Traceback (most recent call last): File \"\", line 1, in File \"\", line 12, in name AttributeError: can't delete attribute >>> vars(X) mappingproxy({'__module__': '__main__', '__init__': , 'name': , '__dict__': , '__weakref__': , '__doc__': None}) @语法被称为修饰器。多个方法名必须相同。默认从读方法开始定义属性，随后以属性名定义写和删除操作。如果实现只读，或禁止删除，则只需去掉对应方法即可。 可用lambda简化代码。 >>> class X: ... name = property( ... fget = lambda self:getattr(self,\"_name\", None), ... fset = lambda self, value: setattr(self,\"_name\", value), ... ) >>> o.name = \"abc\" >>> o.name 'abc' 以方法应对操作，可主动判断是否继续执行。例如，判断赋值数据是否合法，或阻止创建同名实例字段。 >>> class X: ... __data = \"X.data\" ... @property ... def data(self): ... return self.__data ... @data.setter ... def data(self, value): ... if not isinstance(value, str): # 检查数据类型 ... raise ValueError(\"value type must be str\") ... X.__data = value # 直接修改类型字段 ... >>> o = X() >>> o.data = 1 Traceback (most recent call last): File \"\", line 1, in File \"\", line 9, in data ValueError: value type must be str >>> o.data = \"abc\" >>> vars(o) {} >>> o.data 'abc' 属性可实现延迟初始化，而无须提前准备数据。且属性方法调用也未必会绑定字段，可按需要从任意数据源获取。 优先级 尽管属性保存于类型名字空间，其优先级高于同名实例字段。 >>> class X: ... data = property(lambda self: \"X.data\") ... >>> o = X() >>> o.data = 123 # 属性优先，data没有指定赋值方法 AttributeError: can't set attribute >>> o.__dict__[\"data\"] = 123 # 绕开限制，直接对__dict__操作。 >>> vars(o) {'data': 123} >>> o.data 'X.data' 方法 方法是一种特殊函数，其与特定对象绑定，用来获取或修改对象状态。 实际上，无论是对象构造、初始化、析构，还是运算符，都以方法实现。根据绑定目标和调用方式不同，方法可分为实例方法、类型方法以及静态方法。 实例方法与实例对象绑定。其参数列表中，将绑定对象作为第一参数，以便在方法中读取或修改数据状态。在以实例引用调用方法时，无须显式传入第一实参，而由解释器自动完成。建议参数名为self，同样cls作为类型方法的第一参数名。 >>> class X: ... def __init__(self, name): ... self.__name = name ... def get(self): # 以实例引用调用，自动传入self参数 ... return self.__name ... def set(self, value): ... self.__name = value ... >>> o = X(\"Q.yuhen\") >>> o.get() # 忽略第一参数 'Q.yuhen' >>> o.set(\"qyuhen\") 类型方法用来维护类型状态，面向族群提供服务接口。除绑定的第一参数名称不同外，还需添加专门的装饰器，以便解释器将其与实例方法区分开来。 >>> class X: ... __data = \"X.data\" ... @classmethod # 定义为类型方法 ... def get(cls): # 解释器自动将类型对象X作为cls参数传入 ... return cls.__data ... @classmethod ... def set(cls, value): ... cls.__data = value ... >>> X.get() # 同样忽略cls参数 'X.data' >>> X.set(\"hello\") >>> o = X() >>> o.get() 'hello' >>> o.set(\"H\") >>> o.get() 'H' 静态方法则更像普通函数，即不接受实例引用，也不参与类型处理，所以也就没有自动传入的第一参数。使用静态方法，更多原因就是将类型作为一个作用域，或为当前类型添加便捷接口。 >>> class DES: ... def __init__(self, key): ... self.__key = key ... def encrypt_bytes(self, value): # 实例方法 ... pass ... @staticmethod # 定义为静态方法 ... def encrypt(key, s): # 所有参数必须显式传入 ... des = DES(key) ... return DES(key).encrypt_bytes(s.encode(\"utf-8\")) ... >>> DES.encrypt(\"key\", \"abc\") 不论是哪种方法，都保存在类型名字空间中，故不能重名。装饰器和参数的差异，并不能改变在同一名字空间字典中对同一主键重复赋值会覆盖前一次赋值的现实。 >>> class X: ... def test(self): ... pass ... @classmethod ... def test(cls, a): ... pass ... @staticmethod ... def test(x): ... pass ... >>> vars(X) mappingproxy({'__module__': '__main__', 'test': , '__dict__': , '__weakref__': , '__doc__': None}) 绑定 >>> class X: ... def test(self): pass ... >>> o = X() >>> o.test > >>> X.test 同一方法，仅是引用方式不同，结果就有绑定方法和函数区别。这是为啥呢？这是描述符机制在起作用。它会将实例附加到方法的__self__属性，当解释器执行时就可隐式自动传入self参数。 >>> o.test.__self__ is o True >>> X.test.__self__ AttributeError: 'function' object has no attribute '__self__' 当然，就算不是绑定方法，依然可像函数那样调用，无非要显式传入self而已。 >>> X.test(o) # 显式传入self参数 可用method.__func__获取__code__的相关信息。 自带__self__属性后，无论作为参数传递，还是赋值给变量，总能正确引用原实例。 >>> class X: ... def __init__(self, name): ... self.__name = name ... def test(self): ... return self.__name ... >>> a, b = X(\"a\").test, X(\"b\").test #将方法赋值给变量 >>> a() 'a' >>> b() 'b' 与之类似的还有类型方法。其实现方式与实例方法完全相同，甚至连存储类型应用的字段名都还是__self__。至于剩下的静态方法，其不傍他人，总以函数的身份出现。 >>> class X: ... @classmethod ... def class_method(cls): pass ... @staticmethod ... def static_method(): pass ... >>> X.class_method.__self__ is X True >>> X.static_method 特殊方法 下面是几个由解释器自动调用，与对象生命周期相关的方法。 __new__：构造方法，创建对象实例。 __init__：初始化方法，设置实例的相关属性。 __del__：析构方法，实例被回收时调用。 创建实例时，会先后调用构造和初始化方法。 >>> class X: ... def __new__(cls, *args): # 与__init__接收相同的调用参数 ... print(\"__new__\", args) ... return super().__new__(cls) ... def __init__(self, *args): # self由__new__创建并返回 ... print(\"__init__\", args) ... >>> X(1,2) __new__ (1, 2) __init__ (1, 2) 如果__new__方法返回的实例与cls类型不符，将导致__init__无法执行。 >>> class X: ... def __new__(cls): ... print(\"__new__\", cls) ... return [1, 2] ... def __init__(self): ... print(\"__init__\") ... >>> X() __new__ [1, 2] 继承 类最大的好处就是可以继承。一个类继承另一个类时，它自动获得另一个类的所有属性和方法，原有类为父类，新类为子类。子类继承父类所有属性和方法，还可以定义自己属性和方法。 class Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year class ElectricCar(Car): def __init__(self, make, model, year): super.__init__(make, model, year) self.battery_size = 70 对于父类方法，只要不符合子类模拟的行动，都可以重写。可在子类定义一个很父类同名的方法，就可重写父类方法。 使用继承，可让子类保留父类继承而来的精华，并剔除不需要的东西。 面向对象有3个基本特征：封装、继承和多态。 统一类型 Python3不再支持Classic Class，所有类型都是New-Style Class。也就是默认继承自object。 >>> class A: pass ... >>> class B(A): pass ... >>> class C(B): pass ... >>> issubclass(A, object) True >>> type(A) is A.__class__ True >>> B.__base__ # 子类以__base__引为基类 >>> A.__subclasses__() # 基类通过__subclasses__获知所有直接子类。仅返回直接子类 [] __initsubclass\\_是一个隐式类型方法，在所有层次的子类型创建时被调用，其甚至可接收键值参数。 >>> class A: ... def __init_subclass__(cls, **kwargs): ... print(\"init_subclass:\", cls, kwargs) ... >>> class B(A): pass ... init_subclass: {} >>> class C(B, data = \"hello\"): pass # 向基类传递参数 ... init_subclass: {'data': 'hello'} 初始化 初始化方法__init__是可选的。 如果子类没有新的构造参数或新的初始化逻辑，则没必要创建该方法。按搜索顺序，解释器会找到基类初始化方法并执行。同样的缘故，可在子类的初始化方法中显式调用基类方法。 >>> class A: ... def __init__(self): ... print(\"A.init\") ... >>> class B(A): pass ... >>> B() A.init 可使用名字引用基类方法或调用super返回基类代理，以解除对类型名字的直接依赖。 >>> class A: ... def __init__(self, x): ... self.x = x ... >>> class B(A): ... def __init__(self, x, y): ... super().__init__(x) ... self.y = y ... >>> o = B(1,2) >>> vars(o) {'x': 1, 'y': 2} 无论是A.__init__，还是B.__init__，其self参数都引用同一实例对象，所以在不同继承层次里创建的实例字段都存储在同一名字空间中，而不会出现多个同名成员。 覆盖 覆盖(override)是指子类重新定义基类方法，从而实现功能变更。Python只需在搜索优先级更高的名字空间中定义同名方法即可实现覆盖。 覆盖不应改变方法参数列表和返回值类型，须确保不影响原有调用代码和相关文档，这与名字遮蔽不同。无论是多态机制，还是名字搜索顺序，都能确保新定义方法被执行。 >>> class A: ... def m(self): print(\"A.m\") ... def do(self): self.m() # 如果self是B类型，那么搜索首先找到自然是B.m ... >>> class B(A): ... def m(self): print(\"B.m\") # override ... >>> A().do() A.m >>> B().do() B.m 方法搜索发生在运行期，其不会静态绑定具体类型方法。注意的是方法没有属性(property)那样的优先级策略，应避免被实例同名成员遮蔽。 多继承 多重继承允许类型有多个继承体系。从优点来说，提供了一种混入机制，让既有体系的类型可扩展出其他体系功能，但却会导致严重混乱，且让设计和代码的复杂度增大。故须慎重，尽量少用。 >>> class A: ... def a(self): pass ... >>> class B: ... def b(self): pass ... >>> class X(A, B): pass ... >>> dir(X) # 可访问所有基类成员 ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'a', 'b'] >>> X.__base__ # 仅返回单个基类的只读属性 >>> X.__bases__ # 获取全部基类，按继承顺序返回所有全部基类 (, ) >>> class C: ... def c(self): pass ... >>> X.__bases__= (B, A, C) # 调整继承顺序，并添加新基类，实现功能混入 >>> dir(X) # 可访问新基类成员 ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'a', 'b', 'c'] 除横向动态扩展外，还可纵向注入继承体系中。 >>> class A: ... def test(self): print(\"A.test\") ... >>> class B(A): ... pass ... >>> class Proxy(A): ... def test(self): # 拦截A.test调用 ... print(\"proxy\") ... return super().test() ... >>> B.__bases__ = (Proxy,) # 修改B基类，形成B => Proxy => A方式 >>> B().test() proxy A.test __mro__ 任何类型的最终基类都是object，所以多重继承会出现菱形布局。最大问题是多重继承线上出现相同名字的成员时，如何选择？ 这设计成员搜索基本规则：MRO(method resolution order)。对单继承，有近到远向祖先类依次查找。而多继承的复杂性在于深度和广度间的排列。 MRO步骤如下： 按\"深度优先，从左到右\"顺序获取类型列表； 移除列表中重复类型，仅保留最后一个； 确保子类从在基类前，并保留多继承定义顺序。 >>> class Y: ... n = \"Y.n\" ... def test(self): print(\"Y.test\") ... >>> class X(Y): pass ... >>> class N: pass ... >>> class M(N): ... n = \"M.n\" ... def test(self): print(\"M.test\") ... >>> class A(X, M): pass ... # “左侧优先，子类优先” >>> A.__mro__ # __mro__是只读属性，且不能通过实例访问。 (, , , , , ) >>> A().n 'Y.n' >>> A().test() Y.test >>> A.__bases__ = (M, X) # 调整继承顺序，M变为左侧了。 >>> A.__mro__ (, , , , , ) >>> A().test() M.test 应注意避免多条继承线存在交叉的现象，并竭力控制多继承和继承深度。 super 该函数返回基类型代理，完成对基类成员的委托访问。 有2个参数，第二参数对象提供__mro__列表，第一参数则指定起点。函数总是返回起点位置后一类型。这要求第二参数必须是第一参数的实例或子类型，否则第一参数不会出现在列表中。同时，第二参数还是实例和类型方法所需的绑定对象。 看看super算法伪码： def super(t, o): mro = getattr(o, \"__mro__\", type(o).__mro__) # 返回实例或类型mro列表 index = mro.index(t)+1 # 返回列表中的下一类型 return mro[index] 对单继承，通常省略参数，默认使用当前类型和实例，返回直接基类。但对多继承，则须明确指定起点和列表提供者。 >>> class A: ... @classmethod ... def demo(cls): pass ... def test(self): print(\"A\") ... >>> class B(A): ... def test(self): print(\"B\") ... >>> class C(B): ... def test(self): print(\"C\") ... >>> C.__mro__ (, , , ) >>> super(C, C).test >>> super(B, C).test >>> o = C() >>> super(C, o).__self__ is o # 使用__self__作为绑定属性，存储第二参数引用 True >>> super(C, o).test > >>> super(C, C).demo > # 不建议直接使用__class__.__base__访问基类，可能会引发意外错误。如： >>> class A: ... def test(self): ... print(\"A.test\") ... >>> class B(A): ... def test(self): ... print(\"B.test\") # 在B的角度，self.__class__.__base__指向A ... self.__class__.__base__.test(self) # 但实际，self可能是B子类实例，如C ... # 这样self.__class__.__base__实际指向B >>> class C(B): pass # 结果导致B.test被递归 ... >>> C().test() RecursionError: maximum recursion depth exceeded while calling a Python object 正确方式采用显式类型名字访问，或用super函数。即使省略super参数，默认使用当前类型B为搜索起点。这样就可确保访问A.test方法，避免递归错误。即修改为super().test()即可 抽象类 抽象类表示部分完成，且不能被实例化的类型。 作为设计方式，抽象类可分离主体框架和局部实现，或将共用和定制解耦。不同接口纯粹调用声明，抽象类属于继承树的组成部分，可有实现代码。从抽象类继承，必须实现所有层级未被实现的抽象方法，否则无法创建实例。 实现抽象类，须继承abc，或使用ABCMeta元类。 >>> from abc import ABCMeta, abstractmethod >>> class Store(metaclass = ABCMeta): ... def __init__(self, name): ... self.name = name ... def save(self, data): ... with open(self.name, \"wb\") as f: ... d = self.dump(data) ... f.write(d) ... def read(self): ... with open(self.name, \"rb\") as f: ... return self.load(f.read()) ... @abstractmethod ... def dump(self, data): ... ... @abstractmethod ... def load(self, data): ... ... >>> Store(\"test.dat\") Traceback (most recent call last): File \"\", line 1, in TypeError: Can't instantiate abstract class Store with abstract methods dump, load 该示例定义存储框架，并实现了通用部分的接口方法。至于具体的序列化过程，则交由子类完成。如此，可按需创建不同版本。 >>> import pickle >>> class PickleStore(Store): ... def dump(self, data): ... return pickle.dumps(data) ... def load(self, data): ... return pickle.loads(data) ... >>> s = PickleStore(\"test.dat\") >>> s.save({\"x\":1, \"y\":2}) >>> s.read() {'x': 1, 'y': 2} 如从抽象类继承，未实现全部方法，或添加新的抽象定义，那么该类型依然是抽象类。另外，抽象装饰器还可用于属性、类型方法和静态方法。 >>> class A(metaclass = ABCMeta): ... @classmethod # 注意两个装饰器顺序 ... @abstractmethod ... def hello(cls): ... ... >>> class B(A): pass ... >>> B() Traceback (most recent call last): File \"\", line 1, in TypeError: Can't instantiate abstract class B with abstract methods hello >>> class B(A): # 即便抽象类型方法，依然需要实现，否则无法创建实例 ... @classmethod ... def hello(cls): pass ... >>> B() 开放类 在运行期，可动态向实例或类型添加新成员，其中也包括方法。 有别于实例字段，方法需要添加到类型名字空间，因为要作用于所有实例和后续类型。另外，只有添加到类型名字空间才能自动构成绑定，这是有解释器的运行规则所决定的。 将已绑定的方法添加到实例名字空间，只能算是字段赋值，算不上添加方法。而将一个函数添加到实例，即便手动设定__self__也无法构成绑定 >>> class X: pass ... >>> o = X() >>> o.test = lambda self:None # 向实例添加函数字段 >>> o.test.__self__ = o # 尝试手工设定绑定 >>> o.test # 依然无法构成绑定，除非重写描述符的相关方法 at 0x000001D3929FC1E0> >>> o.test() Traceback (most recent call last): File \"\", line 1, in TypeError: () missing 1 required positional argument: 'self' 考虑类型__dict__是一个只读代理，其只能以字段赋值方式添加新方法。如是类型和静态方法，还须调用装饰器函数。 >>> class X:pass ... >>> o = X() >>> X.a = lambda self: print(f\"instance method: {self}\") >>> X.b = classmethod(lambda cls: print(f\"class method: {cls}\")) >>> X.c = staticmethod(lambda: print(\"static method\")) >>> o.a() instance method: >>> o.b() class method: >>> o.c() static method object 作为祖先根类object，有点特殊，无法向其类型和实例添加任何成员 >>> object.x = 1 TypeError: can't set attributes of built-in/extension type 'object' >>> o = object() >>> o.x = 1 AttributeError: 'object' object has no attribute 'x' >>> object().__dict__ # 实例没有__dict__属性 AttributeError: 'object' object has no attribute '__dict__' SimpleNamespace简单继承自object，用于替代那些\"class X: pass\"语句。不同于namedtuple创建结构化类型，SimpleNamespace直接创建实例。 >>> import types >>> o = types.SimpleNamespace(a = 1, b=\"abc\") >>> o.c = [1,2] >>> o.__dict__ {'a': 1, 'b': 'abc', 'c': [1, 2]} __slots__ 名字空间字段带来便利同时，也造成内存和性能问题。 对于需要创建海量实例的类型，须做“固化”处理。通过设置__slots__，阻止实例创建__dict__等成员。解释器仅为指定成员分配空间，添加任何非预置属性都会引发异常。 对于有__slots__设置的类型，解释器在创建类型对象时，直接将指定成员包装成描述符后静态分配到类型对象尾部。实例字段也不再通过__dict__存储，而是改为直接分配引用内存，这样就只能替换引用内容，无法改变成员名字，更无法分配新的成员空间。 成员后续操作均由描述符完成，可间接修改或删除字段内容，但却无法改变描述符本身。 >>> class A: ... __slots__ = (\"x\",\"y\") ... >>> o = A() >>> o.z = 100 # 不能新增属性，因为无法为其分配引用内存 Traceback (most recent call last): File \"\", line 1, in AttributeError: 'A' object has no attribute 'z' >>> o.x = 1 # 只能为预定字段赋值 >>> o.y = 2 >>> o.x = \"abc\" # 通过描述符修改字段内容 >>> o.x 'abc' >>> del o.x # 删除字段内容，但描述符依然存在 >>> o.x = 100 # 引用内存也在，可重新赋值 对__slots__的修改并不会影响类型创建时设定的内存分配策略，加上预定成员以描述符实现，所以也无法更换其名称。 >>> A.__slots__ = (\"x\",\"y\",\"z\") >>> o = A(1,2) TypeError: A() takes no arguments >>> o.z = 3 AttributeError: 'A' object has no attribute 'z' >>> A.__slots__ = (\"a\", \"b\") >>> dir(A) [..., 'x', 'y'] 注意，__slots__限制的是实例，而非类型。因此，还是可为类型添加新成员。如果在__slots__中添加__dict__，可回归其原来样子，不过没啥意义了。 继承有__slots__设置的类型，同样需要添加该设置。其可为空，或是新增字段，以指示解释器继续使用特定分配策略。 >>> class A: ... __slots__ = (\"x\", \"y\") ... def __init__(self, x, y): ... self.x =x ... self.y =y ... >>> class X(A): # 没有__slots__,会创建__dict__ ... def __init__(self,x, y, z): ... super().__init__(x,y) ... self.z = z ... >>> class Y(A): ... __slots__ = (\"z\",) # 新增字段列表，或为空 ... def __init__(self, x, y, z): ... super().__init__(x, y) ... self.z = z ... >>> x = X(1,2,3) >>> x.__dict__ # 包含__dict__，用于存储非__slots__新增成员 {'z': 3} >>> y = Y(1,2,3) >>> y.__dict__ AttributeError: 'Y' object has no attribute '__dict__' >>> dir(y) [..., 'x', 'y', 'z'] 运算符重载 每种运算符都有对应一个特殊名称的方法。解释器会将运算符指令转换成方法调用，方法名可参考标准库的operator文档。运算符重载就是定义目标方法。但不限于运算符，还可包括内置函数和某些语句。 >>> class X: ... def __init__(self, data): ... self.data = data ... def __repr__(self): ... return f\"{self.__class__} {self.data!r}\" ... def __add__(self, other): # 加法 + ... return X(self.data + other.data) ... def __iadd__(self, other): # 增量赋值 += ... self.data.extend(other.data) ... return self ... >>> a, b = X([1, 2]), X([3, 4]) >>> a+b [1, 2, 3, 4] >>> a +=b >>> a [1, 2, 3, 4] __repr__ 函数repr、str都输出对象字符创格式信息。 方法__repr__倾向输出运行期状态，比如类型、id，以及关键性内容，其适应调试和观察。而__str__通常返回内容数据，其面向用户，易阅读，可输出到终端或日志。 >>> class X: ... def __init__(self, x): ... self._x = x ... def __repr__(self): ... return f\"\" ... def __str__(self): ... return str(self._x) ... >>> repr(X(1)) '' >>> str(X(1)) '1' __item__ 为对象添加索引(index)或主键（key）访问。 >>> class X: ... def __init__(self, data = None): ... self.data = data or [] ... def __getitem__(self, index): ... return self.data[index] ... def __setitem__(self, index, value): ... if index >= len(self.data): ... self.data.append(value) ... return ... self.data[index] = value ... def __delitem__(self, index): ... return self.data.pop(index) ... >>> o = X([1, 2, 3, 4]) >>> o[2] = 300 >>> del o[2] >>> o.data [1, 2, 4] __call__ 让对象可像函数一样调用。实现该方法的对象被称为callable，函数也是其中一种。用实例对象替代函数，让逻辑自带内部状态(其封装性比闭包更好)。 >>> class X: ... def __init__(self): ... self.count = 0 ... def __call__(self, s): ... self.count += 1 ... print(s) ... >>> def test(f): ... f(\"abc\") ... >>> test(lambda s:print(s)) abc >>> test(X()) abc >>> o= X() >>> o(\"abc\") abc __dir__ 定制dir函数返回值，隐藏部分成员。 >>> class X: ... def __dir__(self): ... return (m for m in vars(self).keys() if not m.startswith(\"__\")) ... >>> o = X() >>> o.a =1 >>> o.b = 2 >>> dir(o) ['a', 'b'] >>> o.__c = \"abc\" >>> dir(o) ['a', 'b'] __getattr__ 几个与实例属性访问相关方法： __getattr__： 当整个搜索路径都找不到目标属性时触发。 __setattr__： 拦截对任何属性的赋值操作。 __delattr__： 拦截对任何属性的删除操作。 拦截到赋值和删除操作后，由拦截方法负责处理赋值和删除行为，忽略则被视为放弃该操作。 在拦截方法内部，通过属性或setattr等函数调用都可能再次被拦截，甚至引发递归调用错误。应直接操作__dict__，或使用基类object.__setattr__方法。 >>> class A: ... a = 1234 ... >>> class B(A): ... def __init__(self, x): ... self.x = x ... def __getattr__(self, name): ... print(f\"get: {name}\") ... return self.__dict__.get(name) ... def __setattr__(self, name, value): ... print(f\"set: {name} = {value}\") ... self.__dict__[name] = value ... def __delattr__(self, name): ... print(f\"del: {name}\") ... self.__dict__.pop(name, None) ... >>> o = B(1) set: x = 1 # 拦截B.__init__里对self.x的赋值操作 >>> o.a # 搜索路径里能找到的成员，不会触发__getattr__ 1234 >>> o.xxx # 找不到，才会触发 get: xxx >>> o.x = 100 # 任何赋值操作都会被__setattr__拦截(无论其是否存在) set: x = 100 >>> del o.x # 拦截任何删除操作，(无论其是否存在) del: x 方法__getattribute__拦截任何实例属性的访问(无论其是否存在)。 拦截目标包括__dict__，这意味着只能通过基类方法进行操作。 访问不存在的成员时，__getattribute__拦截后不再触发__getattr__，除非显式调用或触发异常。 在下面实例中，因object.__getattribute__找不到目标属性，所以会触发A.__getattr__调用，继而还会拦截到其内部对__dict__的访问。 >>> class A: ... def __init__(self, x): ... self.x = x ... def __getattribute__(self, name): # 返回结果，或引发AttributeError ... print(f\"getattribute: {name}\") ... return object.__getattribute__(self, name) ... def __getattr__(self, name): ... print(f\"getattr: {name}\") ... return self.__dict__.get(name) ... >>> o = A(1) >>> o.x # 无论其是否存在，均被拦截 getattribute: x 1 >>> o.s getattribute: s # __getattribute__拦截 getattr: s # object.__getattribute__找不到s,触发__getattr__ getattribute: __dict__ # __getattr__访问__dict__被再次拦截 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/meta.html":{"url":"basic/meta.html","title":"元编程","keywords":"","body":"元编程 元编程将程序当做数据，或在运行期完成编译器的工作。 1、装饰器 代码可利用装饰器，在不浸入内部实现，甚至在不知情的情况下，插入扩展逻辑。 >>> @log ... def add(x, y): ... return x + y 编译器会将装饰器语法处理成如下模式。 >>> def add(x, y): ... return x + y ... >>> add = log(add) 对按名字搜索执行的调用函数，根本察觉不到。而被调用函数，只要能收到正确参数即可。这样，就可在任何时候添加额外的处理过程了。从装饰器语法和实现效果来看，类似AOP编程范式。 1.1、实现 基于装饰器的实际执行方式，可直接以函数实现。 >>> def log(fn): ... def wrap(*args, **kwargs): # 通过包装函数间接调用原函数 ... print(f\"log: {args}, {kwargs}\") ... return fn(*args, **kwargs) ... return wrap # 返回包装函数替代原函数与名字关联 ... >>> @log ... def add(x, y): ... return x +y ... >>> add(1, 2) log: (1, 2), {} 3 其返回包装代理，或仅添加一些额外属性后，原样返回。 >>> def log(fn): ... fn.log_func = lambda *args, **kwargs: print(f\"log: {args}, {kwargs}\") ... return fn 同样，任何可调用对象(callable)都可用来实现装饰器模式。 >>> class log: ... def __init__(self, fn): ... self.fn = fn ... def __call__(self, *args, **kwargs): ... print(f\"log: {args}, {kwargs}\") ... return self.fn(*args, **kwargs) ... >>> @log ... def add(x, y): ... return x + y ... >>> add(1, 4) log: (1, 4), {} 5 因每条“@log”都会被处理成“log(add)”，也就是每次都会新建一个实例。所以，其应用于多个目标函数完全没问题。 相比于函数，使用类实现似乎可构建更复杂的装饰器，但这存在一些麻烦。类实现的装饰器应用于实例方法时，会导致方法绑定丢失。 >>> class log: ... def __init__(self, fn): ... self.fn = fn ... def __call__(self, *args, **kwargs): ... print(f\"log: {args}, {kwargs}\") ... return self.fn(*args, **kwargs) ... >>> class X: ... @log ... def test(self): pass ... >>> x = X() >>> x.test # 方法被装饰器实例所替代 >>> x.test() log: (), {} Traceback (most recent call last): File \"\", line 1, in File \"\", line 6, in __call__ TypeError: test() missing 1 required positional argument: 'self' 因装饰器实例替代了方法，结果导致实现绑定的描述符方法被隐藏，无法自动调用。要么让装饰器也实现描述符协议，要么显式传递参数。这样反而不如用函数来的简单，因为函数对象默认实现了描述符协议和绑定规则。至于状态维持，函数一样可以添加属性。 >>> def log(fn): ... def wrap(*args, **kwargs): ... print(f\"log: {args}, {kwargs}\") ... return fn(*args, **kwargs) ... return wrap ... >>> class X: ... @log ... def test(self): pass ... >>> x = X() >>> x.test .wrap of > >>> log.__get__ # 函数默认实现了描述符协议 嵌套 嵌套对一个目标使用多个装饰器。 @a @b def test(): pass 最终效果就是多次嵌套调用。 test = a(b(test)) 装饰器接收前一装饰器的返回值，该返回值可能是包装对象或是原函数。如此，就需要注意排列顺序，因为每个装饰器的返回值并不相同。比如，须确保类型方法的装饰器是最外面一个，因为无法确定内层装饰器如何实现。这可能也会因描述符问题，导致方法绑定失效。 class X: @classmethod # 注意放在最外层 @log def test(cls): pass 参数 除被装饰目标外，还可向装饰器传递其他参数。以实现更多定特性。 @log(\"demo\") def test(): pass 这样，就多了一个处理过程。 >>> def log(name = \"default\"): # 外层函数接收参数 ... print(f\"args: {name}\") ... def decorator(fn): # 装饰器 ... print(f\"decorator: {fn}\") ... return fn # 返回包装函数或原函数 ... return decorator ... >>> @log(\"demo\") ... def test(): pass ... args: demo decorator: >>> @log() # 对于有参数的装饰器，如有默认值须括号。 ... def test(): pass ... args: default decorator: 属性 可让包装函数更像原函数一些，比如拥有某些相同属性。 >>> import functools >>> def log(fn): ... @functools.wraps(fn) ... def wrap(*args, **kwargs): ... return fn(*args, **kwargs) ... print(f\"wrap: {id(wrap)}, func: {id(fn)}\") ... return wrap ... >>> @log ... def add(x: int, y: int) -> int: ... return x + y ... wrap: 1714291384800, func: 1714291385208 >>> add.__name__ 'add' >>> add.__annotations__ {'x': , 'y': , 'return': } >>> id(add), id(add.__wrapped__) (1714291384800, 1714291385208) 装饰器functools.wrap将原函数__module__、__name__、__doc__、__annotations__等属性复制到包装函数，还用__wrapped__存储原始函数或上一装饰器返回值。可由此判断并绕开装饰器对单元测试的干扰。 类型装饰器 装饰器同样可用于类型，这里的区别无非是接收参数为类型对象而已。 >>> def log(cls): ... class wrapper: ... def __init__(self, *args, **kwargs): ... self.__dict__[\"inst\"] = cls(*args, **kwargs) ... def __getattr__(self, name): ... value = getattr(self.inst, name) ... print(f\"get: {name} = {value}\") ... return value ... def __setattr__(self, name, value): ... print(f\"set: {name} = {value}\") ... return setattr(self.inst, name, value) ... return wrapper ... >>> @log ... class X: pass ... >>> x = X() >>> x.a = 1 set: a = 1 >>> x.a get: a = 1 1 因每次都新建wrapper类型，故可应用于不同类型目标。 当然，未必要返回包装类，也可用函数代替，间接调用目标构造方法创建实例。 >>> def log(cls): ... def wrap(*args, **kwargs): ... o = cls(*args, **kwargs) ... print(f\"log: {o}\") ... return o ... return wrap ... >>> @log ... class X: pass ... >>> X() log: 1.2、应用 利用装饰器功能，可编写各种辅助开发工具。如调试跟踪、性能测试、内存检测等。也可用于模式设计，改善代码结构。 调用跟踪 记录目标调用参数、返回值，以及执行次数和执行时间等信息。 >>> def call_count(fn): ... def counter(*args, **kwargs): ... counter.__count__ += 1 ... return fn(*args, **kwargs) ... counter.__count__ = 0 ... return counter ... >>> @call_count ... def a(): pass ... >>> @call_count ... def b(): pass ... >>> a(); a(); a.__count__ 2 >>> b(); b(); b(); b.__count__ 3 在标准库中有类似的应用，通过缓存结果减少目标执行次数。 In [1]: import functools In [2]: @functools.lru_cache(10) ...: def test(x): ...: time.sleep(x) ...: In [3]: import time In [4]: %%time ...: for i in range(1000): test(1) ...: ...: Wall time: 1 s 属性管理 为目标添加额外属性，在原有设计上以装配方式混入(mixin)其他功能组。 >>> def pet(cls): ... cls.dosomething = lambda self: None ... return cls ... >>> @pet # 添加类似宠物功能 ... class Parrot: pass ... 比起前面章节提及的直接添加基类(__bases__)方式，装饰器更好点。 还可用代理类拦截(__getattr__、__setattr__)对目标进行访问，比如实现只读功能。 实例管理 替代目标构造方法，拦截实例的创建。用于实现对象缓存，或单例模式。 >>> def singleton(cls): ... inst = None ... def wrap(*args, **kwargs): ... nonlocal inst ... if not inst: inst = cls(*args, **kwargs) ... return inst ... return wrap ... >>> @singleton ... class X: pass ... >>> X() is X() True 部件注册 在很多Web框架里，用装饰器替代配置文件实现路由注册。 >>> class App: ... def __init__(self): ... self.routers = {} ... def route(self, url): ... def register(fn): ... self.routers[url] = fn ... return fn ... return register ... >>> app = App() >>> @app.route(\"/\") ... def index(): pass ... >>> @app.route(\"/help\") ... def help(): pass ... >>> app.routers {'/': , '/help': } 2、描述符 描述符一致被解释器当秘密武器使用。前面提及的属性、方法绑定等内部机制都是描述符在起作用。 不同于实例通过拦截方法（__getattr__等），描述符以单个属性出现，并针对该属性的不同访问行为自动做出响应。最重要的是，描述符能\"感知\"通过什么引用该属性，从而和目标建立绑定关联。 >>> class descriptor: ... def __set_name__(self, owner, name): ... print(f\"name: {owner.__name__}.{name}\") ... self.name = f\"__{name}__\" ... def __get__(self, instance, owner): ... print(f\"get: {instance}, {owner}\") ... return getattr(instance, self.name, None) ... def __set__(self, instance, value): ... print(f\"set: {instance}, {value}\") ... setattr(instance, self.name, value) ... def __delete__(self, instance): ... print(f\"del: {instance}\") ... raise AttributeError(\"delete is disabled\") ... >>> class X: ... data = descriptor() ... name: X.data 描述符属性必须定义为类型成员，所以其自身不适合存储实例相关的状态。在创建属性时，__set_name__方法被调用，并可通过参数获知目标类型（owner）,以及属性名称。 以类型或实例访问描述符属性时，__get__被自动调用，且会接收到类型和实例引用。 >>> x = X() >>> x.data = 100 set: , 100 >>> x.data get: , 100 方法__set__、__delete__仅在实例引用时被调用。以类型引用进行赋值或删除操作，会导致描述符属性被替换或删除。 >>> X.data get: None, >>> X.data = 100 # 以类型引用赋值，导致描述符属性被替换 >>> X.data 100 还有，将描述符属性赋值给变量或传参时，实际结果是__get__方法的返回值。 >>> x = X() >>> x.data = 100 set: , 100 >>> o = x.data get: , >>> o 100 数据描述符 如果定义了__set__或__delete__方法，那么我们便称其为数据描述符。而仅有__get__d的则是非数据描述符。这两者的区别在于，数据描述符属性的优先级高于实例名字空间中的同名成员。 >>> class descriptor: ... def __get__(self, instance, owner): ... print(\"__get__\") ... def __set__(self, instance, value): ... print(\"__set__\") ... >>> class X: ... data = descriptor() ... >>> x = X() >>> x.__dict__[\"data\"] = 0 >>> x.data = 100 __set__ >>> x.data __get__ 但如果注释__set__，使其变成非数据描述符，在执行时，结果不一样了。 >>> class descriptor: ... def __get__(self, instance, owner): ... print(\"__get__\") ... >>> class X: ... data = descriptor() ... >>> x = X() >>> x.data = 10 # 同名实例成员的优先级高于非数据描述符 >>> x.data 10 >>> vars(x) {'data': 10} 属性（property）就是数据描述符。就算没有提供setter方法，但__set__依然存在，所以其优先级高于同名实例成员。 >>> p = property() >>> p.__get__ >>> p.__set__ >>> p.__delete__ 方法绑定 因为函数默认实现了描述符协议，所以当以实例或类型访问方法时，__get__首先被调用。 类型和实例作为参数被传入__get__，从而拦截绑定目标（__self__），如此就将函数包装成绑定方法对象返回。实际被执行的，就是这个会隐式传入第一参数的包装品。 >>> class X: ... def test(self, o): print(o) ... >>> x = X() >>> x.test > >>> x.test(123) 123 >>> m = x.test.__get__(x, type(x)) >>> X.test(m.__self__, 123) 123 >>> m > >>> m.__self__, m.__func__ (, ) x.test(123)实际分成了2个步骤来执行： x.test(123) ---> m = x.test.__get__(x, type(x)) #将函数包装为绑定方法 m(123) ---> X.test(m.__self__, 123) # 执行时，隐式将self/cls参数传给目标函数。 在绑定方法对象内，__self__和__func__存储了执行所需的信息。 3、元类 元类（metaclass）制造了所有类型对象，并将其与逻辑上的父类关联起来。所以，存在两条线：创建和逻辑。 系统默认的元类是type，所以可描述如下过程。 base = type(\"base\", object, ...) class = type(\"class\", base, ...) instance = class(...) instance.__class__ is class and isinstance(instance, class) class.__class__ is type and isinstance(class, type) base.__class__ is type and isinstance(base, type) 属性__class__表明该对象由何种类型创建，可用type(o)返回。 实际上，可用type直接创建类型对象。 >>> User = type(\"User\",(object,),{ ... \"__init__\": lambda self, name: setattr(self, \"name\", name), ... \"test\" : lambda self: print(self.name), ... \"table\" : \"user\", ... }) >>> User.__dict__ mappingproxy({'__init__': at 0x0000014E7E5607B8>, 'test': at 0x0000014E7E577620>, 'table': 'user', '__module__': '__main__', '__dict__': , '__weakref__': , '__doc__': None}) >>> u = User(\"yuhen\") >>> u.test() yuhen >>> u.__dict__ {'name': 'yuhen'} 3.1、 自定义 可自定义元类，以控制类型对象的生成过程。通常自type继承，以Meta为后缀名。 >>> class DemoMeta(type): pass ... >>> class X(metaclass = DemoMeta): pass ... >>> X.__class__ 与普通类型构造过程类似，可覆盖构造和初始化方法的定制创建过程。 >>> class DemoMeta(type): ... @classmethod ... def __prepare__(cls, name, bases): ... print(f\"__prepare__: {name}\") ... return {\"__make__\": \"make in DemoMeta\"} # 定制名字空间 ... def __new__(cls, name, bases, attrs): ... print(f\"__new__: {name}, {bases}, {attrs}\") ... return type.__new__(cls, name, bases, attrs) # 创建并返回类型对象 ... def __init__(self, name, bases, attrs): ... print(f\"__init__: {self}\") ... return type.__init__(self, name, bases, attrs) # 初始化后，返回类型对象 ... def __call__(cls, *args, **kwargs): ... print(f\"__call__: {cls}, {args}, {kwargs}\") ... return type.__call__(cls, *args, **kwargs) #调用类型对象创建实例过程，返回实例 按需去实现相关方法。 __prepare__用来创建类型对象名字空间（X.__dict__），可往里添加点或使用自定义字典类型。随后，该名字空间会填充其他属性成员，并继续传给__new__和__init__方法。 class X(metaclass = DemoMeta) ---> namespace = DemoMeta.__prepare__(name, ...) X = DemoMeta.__new__(name, bases, namespace{attrs}) DemoMeta.__init(X, ...) __call__在类型对象(X)创建其所属的实例时被调用。实际上X.__new__、X.__init__方法就是由此调用的，可用于拦截实例的创建。 o = X(1, 2) ---> o = DemoMeta.__call__(X, 1, 2) ---> o = X.__new__(...) X.__init__(o, ...) >>> class X(metaclass = DemoMeta): ... data = 100 ... def __init__(self, x, y): pass ... def test(self): pass ... __prepare__: X __new__: X, (), {'__make__': 'make in DemoMeta', '__module__': '__main__', '__qualname__': 'X', 'data': 100, '__init__': , 'test': } __init__: >>> o = X(1, 2) __call__: , (1, 2), {} >>> o 当然，这里也可用函数或其他可调用对象代替。 >>> def demo_meta(name, bases, attrs): ... print(f\"{name}, {bases}, {attrs}\") ... return type(name, bases, attrs) ... >>> class X(metaclass = demo_meta): ... data = 100 ... def __init__(self, x, y): pass ... def test(self): pass ... X, (), {'__module__': '__main__', '__qualname__': 'X', 'data': 100, '__init__': , 'test': } 函数只是拦截调用，类型对象的创建依然使用type完成。 参数 还可向元类传递参数，实现功能定制。 >>> class DemoMeta(type): ... def __new__(meta, name, bases, attrs, **kwargs): ... print(kwargs) ... return type.__new__(meta, name, bases, attrs) ... >>> class X(metaclass = DemoMeta, a = 1, b = \"abc\"): ... def test(self): pass ... {'a': 1, 'b': 'abc'} 继承 类型对象的元类设置顺序如下: 1、从metaclass显式指定； 2、从基类继承； 3、默认元类type。 >>> class DemoMeta(type): pass ... >>> class X(metaclass = DemoMeta): pass ... >>> class Y(X): pass # 从基类继承元类 >>> type(Y) 如是多继承，则必须保证能继承所有的祖先元类。 >>> class AMeta(type): pass ... >>> class BMeta(type): pass ... >>> class A(metaclass = AMeta): pass ... >>> class B(metaclass = BMeta): pass ... >>> class C(A, B): pass ... TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases 因为__class__只能指向一个元类，所以除非祖先元类之间存在继承关系，否则必然会由于无法访问而导致错误发生。为此，须新建一个元类，让其继承所有的祖先元类。 >>> class CMeta(AMeta, BMeta): pass ... >>> class C(A, B, metaclass = CMeta): pass 3.2、应用 基于元类，可实现很多魔法，让对象拥有很高的隐式“智能”，但会提升代码复杂度。 另，元类虽能像普通类型那样为自己的实例提供共享成员，但依旧避免使用，能让元类专注于类型创建和管理，不要涉及逻辑最好。 静态类 阻止类型创建实例对象。 这里直接用__call__拦截实例的创建即可。 >>> class StaticClassMeta(type): ... def __call__(cls, *args, **kwargs): ... raise RuntimeError(\"can't create object for static class\") ... >>> class X(metaclass = StaticClassMeta): pass ... >>> x = X() RuntimeError: can't create object for static class 密封类 阻止类被继承。可使用该元类，也就是不能被继承类添加到集合里，作为后续基类判断条件即可。 >>> class SealedClassMeta(type): ... types = set() ... def __init__(cls, name, bases, attrs): ... if cls.types & set(bases): raise RuntimeError(\"can't inherit from sealed class\") ... cls.types.add(cls) ... >>> class A(metaclass = SealedClassMeta): pass ... >>> class B(A): pass ... RuntimeError: can't inherit from sealed class >>> 注解 注解（annotation）为函数参数、返回值，以及模块和类型属性添加额外的元数据。 >>> def add(x: int, y: int) -> int: ... return x + y ... >>> add.__annotations__ {'x': , 'y': , 'return': } 其本质仅是一种可编程和可执行的注释，在编译期被提取，并与对象相关联。在运行期，其对解释器指令的执行没有任何影响和约束。 >>> add(\"abc\", \"d\") # 并不受注解int类型约束 'abcd' >>> import dis >>> dis.dis(add) # 字节码指令中也没有任何注解相关内容 2 0 LOAD_FAST 0 (x) 2 LOAD_FAST 1 (y) 4 BINARY_ADD 6 RETURN_VALUE >>> dis.dis(compile(\"add('abc', 'd')\",\"\",\"exec\")) # 和普通函数调用一致 1 0 LOAD_NAME 0 (add) 2 LOAD_CONST 0 ('abc') 4 LOAD_CONST 1 ('d') 6 CALL_FUNCTION 2 8 POP_TOP 10 LOAD_CONST 2 (None) 12 RETURN_VALUE 注解内容可是任何对象和表达式。其可应用于变量，但不可用于lambda函数。 >>> x: int = 123 # 注意和等号后的初始化值分开 >>> __annotations__ {'x': } >>> def test(x: {'type': int, 'range': (0, 10)} =5): # 等号后为默认值 ... pass ... >>> test.__annotations__ {'x': {'type': , 'range': (0, 10)}} >>> test.__defaults__ (5,) >>> class X: ... data: int = 10 ... def test(self, o: str) -> str: pass ... >>> X.__annotations__ {'data': } >>> X.test.__annotations__ {'o': , 'return': } 用途 注解最常见的用途就是作为类型和取值范围的检查条件，在ORM框架中常见。 >>> def test(x: (int, 0, 10)): ... if __debug__: ... ann_x = test.__annotations__[\"x\"] ... assert isinstance(x, ann_x[0]) ... assert ann_x[1] 更好的做法就是使用装饰器完成，成为一个普通检查器。 其还可为代码编辑器(PyCharm)和帮助生成工具(pydoc)提供更详细的分类信息。另有MyPy等实验型解释器，借助注解实现编译器静态类型检查。 标准库typing提供了基于注解的编程支持。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/exception.html":{"url":"basic/exception.html","title":"异常","keywords":"","body":"异常 在执行期出现的错误就是异常。当Python在处理发生的错误时会创建一个异常对象。如果编写了处理该异常的代码，则程序继续运行，如未对异常进行处理，则程序停止，并显示traceback，其中会包含异常的报告。 异常使用try-except代码块来处理。比如 print(10/0) Python会显示如下traceback： Traceback (most recent call last): File \"\", line 1, in ZeroDivisionError: division by zero 但使用了try-except代码块处理异常后，则不同了，如下： try: print(10/0) except ZeroDivisionError: print(\"you can't divide by zero!\") 这样就不会出现traceback了，会正常打印一条友好的错误消息。 如发生错误，而程序还没有完成，则妥善处理错误会很重要。如处理的好，则程序不会崩溃。 try-except-else代码块： 上面介绍了try-except代码块，可用来提高程序处理错误的能力。try代码块错误后会进入到except代码块，但执行成功后会进入到else代码块中。只有能引发异常的代码才需要放在try语句中。如try语句执行成功后需要运行代码应该放在else代码块中。except代码块是程序尝试运行try代码块引发指定异常后进行处理，如果想什么都不处理，将错误一声不吭的处理掉，可使用代码pass。 文件处理时很容易出现错误，比如文件找不大，这时就会出现FileNotFoundError异常，那么在处理文件时就需要处理FileNotFoundError异常。比如: filename = 'a.txt' try: with open(filename) as f： contents = f.read() except FileNotFoundError: print('the file '+filename+' does not exist') else: print(contents) © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/inout.html":{"url":"basic/inout.html","title":"输入输出","keywords":"","body":"输入输出 有时程序必须等待用户输入才可继续工作，那么怎么通过获取用户输入来控制程序呢？ input() 函数input()会让程序暂停等待用户输入，然后将输入作为变量存储以便用户使用。比如： name = input(\"请问您怎么称呼呢？请输入您的称呼：\") print(\"Hello\" + name+\"!\") age = input(\"您多大了呢？请输入年龄：\") print(age) 好了，上面年龄显示出来是字符串形式，比如我输入年龄时输入了非数字字符，或者年龄要以数字来进行计算或判断呢？这可使用int()来转换。 age = input(\"您多大了呢？请输入年龄：\") age = int(age) age >=18 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/file.html":{"url":"basic/file.html","title":"文件操作","keywords":"","body":"文件操作 可以用Python来处理文件，让程序能读取文件内容并进行分析或处理。 文件读取 文本文件可以存储很多信息。当需要分析或修改存储文件中的信息时，就需要先读取文件。读取文件会首先将信息读取到内存中，为此，可一次性读取文件全部内容，也可每次一行的逐步读取。 比如有的写有圆周率的文本。内容忽略，可自动定义，就是有写有圆周率的几行数字吧，比如这个文件叫pi.txt。 with open('pi.txt') as f: contents = f.read() print(contents) 注意，使用关键字with，则不需考虑文件关闭，在访问完成后就自动将其关闭了。如果不使用with来打开文件，则需要显式的调用close()来关闭文件。 在打开文件时，并没有指定路径，那Python会在当前目录，也就是你代码保存为py文件所在的路径来查找文件。 可使用绝对路径以及相对路径。绝对路径就是准确指出文件路径，也就是绝对文件路径。相对路径是相对当前py文件所在路径的。同时要注意操作系统，如linux的文件路径为(\\)，为window的文件路径为(/)。 上面代码是一次读取，如要逐行读取，可如下： with open('pi.txt') as f: for line in f: print(line) 读取文件时，Python将其中文本都读取为字符串。如要将其作为数值使用，可使用int()将其转为整数，或使用函数float()将其转为浮点数。 Python可处理大文本。只要内存足够大，多少数据都能处理。 写入文本 要将内容写入到文件，一样调用open()，不过需要指定另一个实参。比如： with open('pi.txt', 'w') as f: f.write(\"3.1415926535\") 这里介绍下open()函数，第一个实参为文件名称，第二个为操作模式，缺省为'r'，可省略，所以读取时省略了这个实参。这个实参如下：读取模式('r')，写入模式(‘w’)，附件模式('a')，读取和写入模式('r+')。 如要写入文件不存在，则会自动创建它。然后，以写入模式打开文件时如指定文件已经存在了，那么会返回文件对象前清空该文件。 如写入文件内容为多行，必须在每行末尾加上换行符\\n。为了格式好看，也可使用空格、制表符、换行符等来设置输出格式。 如果要将文件添加内容，而不是覆盖以前的内容，请以附加模式来打开文件。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/unittest.html":{"url":"basic/unittest.html","title":"单元测试","keywords":"","body":"单元测试 编写完代码后，只有通过了测试，才可确定代码是否按要求完成指定的工作。 函数测试 比如有段代码如下，保存在name.py中。 def get_name(first,last): full_name = first+’ ‘+last return full_name.title() 要进行测试比如导入模块unittest以及要测试的函数。在创建一个unittest.TestCase类，并编写一系列方法对函数进行不同测试。 import unittest from name import get_name class NamesTestCase(unittest.TestCase): def test_full_name(self): name = get_name('janis','joplin') self.assertEqual(name, 'Janis Joplin') unittest.main() 上面使用了unittest类常用功能之一：断言方法。断言方法用来核实得到的结果是否与预期的结果一致。如果相同，则测试通过，否则，则测试通不过。 如果测试未通过怎么办呢？需要检查条件是否错误，如果条件正确，而结果不对，则函数可能有问题，修改代码，然后继续测试，知道符合预期结果。 测试类 unittest.TestCase类中提供了很多断言方法。断言方法检查应该满足的条件是否满足，如果满足，则程序正确，如果不满足，则程序可能代码有问题或者发生了异常。下面表格介绍断言方法： 方法 用途 assertEqual(a, b) 核实 a == b assertNotEqual(a, b) 核实 a != b asserTrue(x) 核实x为True assertFalse(x) 核实x为False assertIn(Item, list) 核实item在list中 assertNotIn(Item, list) 核实item不在list中 除了断言方法，还有个方法setUp()，该方法只需在测试类中创建测试对象一次，然后在每个测试方法中就可使用它了。也就是setUp()方法可实例要初始的类以及初始化类的属性，以便在测试方法中能重复使用实例，而不需要重复创建。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"module/":{"url":"module/","title":"内置模块","keywords":"","body":"内置模块 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"common/":{"url":"common/","title":"常用模块","keywords":"","body":"常用模块 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"common/requests.html":{"url":"common/requests.html","title":"requests","keywords":"","body":"requests © 2019 Dastone Deng . All rights reserved.本站访客数 人次"}}