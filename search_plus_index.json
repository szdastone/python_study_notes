{"./":{"url":"./","title":"简介","keywords":"","body":"简介 个人学习Python的学习记录！ © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"install/":{"url":"install/","title":"安装","keywords":"","body":"安装 要安装python，那么就需要去官网先了解，链接如下： 【官方网站】：http://python.org 【下载网址】：https://www.python.org/downloads 当前的版本为3.7.3，那我们就以这个版本为准进行安装以及后面的学习！ 另外提供一些python学习网站： 【第三方库】：https://pypi.python.org/pypi 【官方文档】：https://docs.python.org/zh-cn/3/ 【中文教程】：http://www.runoob.com/python3/python3-tutorial.html 【Awesome Python】：https://github.com/vinta/awesome-python 【Awesome Python中文版】：https://github.com/jobbole/awesome-python-cn 【廖雪峰的Python教程】：https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"install/install.html":{"url":"install/install.html","title":"安装","keywords":"","body":"安装 Winodws安装 windows安装很简单，下载了安装包直接按提示一步一步安装即可，这里不再介绍。安装完成后，请将Python安装路径以及Scripts目录配置到环境变量中。 另外介绍下Anaconda安装，在Anaconda网站下载Windows下对应的Python3版本，进行标准安装即可。 Anaconda安装完成后，python的环境就配置好了。 Linux安装 由于我只安装了Ubuntu的虚拟环境，所以只介绍Ubuntu下安装Python。 其实安装完Ubuntu 18.04以后，系统就以及安装好了python2.7以及python3.6，如果需要源码安装Python3.7.3，则请参考我另外的文档：Ubuntu 中安装与配置 Python3.7 Linux下也支持Anaconda，可在Anaconda网站下载Linux下对应的Python3版本，按提示安装既可以。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"install/venv.html":{"url":"install/venv.html","title":"虚拟环境","keywords":"","body":"虚拟环境 什么是Python的虚拟环境呢？其实Python虚拟环境就是为项目创建的相对独立的开发环境，也就是可为每个项目安装各自独立使用的依赖模块。 解释了可能还是不明白，我最初也是不明白的，到底我只是学习python，搞那么多环境干啥呢？这里在举例解释下，比如你有2个python项目，同时都用到了某个第三方模块numpy，如果这2个项目使用同一个版本的numpy模块，那么不可能产生疑问。但如果使用了不同版本的numpy模块呢？由于python导入模块时并不能区分模块的版本，那么这2个使用不同版本numpy模块的项目就会出现问题了。 那怎么使用虚拟环境呢？在Python3中，默认安装了pyvenv。直接使用就可以了。 创建一个虚拟环境: $python3 -m venv pyvenv2 其中pyvenv2是虚拟环境建立的路径，可根据需求自行定义，该命令会自动在当前目录下建立目录，并将python环境copy到这个目录，该目录结构为： 图：1554967797901 要激活刚才创建的虚拟环境pyvenv2，那么只需要输入如下代码： $source pyvenv2/bin/activate 成功后，则提示符前会加入环境名称，如下： (pyvenv2) $ 如果要退出虚拟环境，那么直接输入： (pyvenv2) $deactivate 好了，验证下虚拟环境。在Python非虚拟环境下，输入命令： $which python /usr/bin/python 激活虚拟环境pyvenv2后，再次查看python路径： $source pyvenv2/bin/activate （pyvenv2）$which python /home/dastone/pyvenv2/bin/python 如果我们查看下环境变量$PATH，会发现这个变量在激活前后是不同的。 我们也可在python中查看环境变量以及pip的site packages目录： 图：1554970396705 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/":{"url":"basic/","title":"基础","keywords":"","body":"基础 在Python中，要了解class以及instance。所有的变量都有自己的class，一旦赋值以后就实例化(instance)了。每个变量都是自己的唯一ID值。 >>>id(123) 140734734037456 >>>id('abc') 2390831392056 不同Python实现使用了不同算法，CPython用内存地址作为ID值。所以ID不适合为全局身份标识，因为内存地址有可能会被重复使用。比如： >>> a = 123 >>>id(a) 140734734037456 #和上面id(123)的地址是一致的 >>>c=a >>>id(c) 140734734037456 可用type返回实例所属类型。比如： >>>type(123) >>>type(1.23) >>>type(True) >>>type(\"hello\") 要判断实例是否属于某个类型，可使用isinstance函数，比如： >>>isinstance(123,int) True >>>isinstance(1.23, float) True 注意，所有类型都属于类型object。object是所有类型的基类，提供了一些基本属性及操作方法等，所有类型都继承自object。但所有类型都是有type创建的，这和继承无关，如： >>>issubclass(int, object) True >>>id(int) 140734733558240 >>>type(int) >>>isinstance(int, type) True >>>issubclass(type,object) True 类型对象属于创建者这样特殊存在。默认情况下，它们在解释器首次载入时自动生成，生命周期与进程相同，且仅有一个实例。 变量 变量是具有特别格式的内存，而变量名则为内存别名，变量名与指针是不同的。Python是一种动态类型语言，也就是只有在运行时才知道变量名的类型。所以变量名必须和目标对象关联才可以，而最直接关联就是赋值，而后对变量名引用都解释为对目标对象的操作。 名字空间(namespace)是上下文环境中专门用来存储名字和目标引用关联的容器。在Python中，每个模块都有一个全局名字空间。而根据作用域，又会有当前名字空间或本地名字空间。内存函数globals和locals分别返回全局名字空间和本地名字空间字典。globals一般固定指向模块名字空间，而locals则指向当前作用域空间。 了解了名字空间，就知道变量名只是字符串主键，自身的数据结构中并没有任何目标对象信息。通过变量名访问目标对象，就是以名字为主键去空间字典中读取目标对象指针引用。所以，变量名可重新关联另一对象，而不在乎其类型是否与以前相同。 >>>x=100 >>id(x) 140705733701360 >>>globals() {...,'x':100} >>>x=\"abc\" #重新关联其他对象，没有类型限制 >>>id(x) #通过输出id，可看出关联新对象，而非修改原对象内容 1843192063288 >>>globals() #名字空间里引用发生了变更 {...,'x':'abc'} >>>locals() #模块作用域中，可通过id查看，globals与locals相同 {...,'x':'abc'} 赋值操作只是变量名在名字空间里重新关联，而非修改对象。单个对象可以同时又多个变量名。可用is来判断2个变量名是否引用同一对象。相等操作符会判断值是否相同。 >>>a = 2345 #请使用大数字，小数字常量会被缓存 >>>b = a >>>a is b True >>>c = 2345 >>>a is c False >>>a == c True >>>globals() #2345会有不同变量名 {...,'a':'2345','b':'2345','c':'2345'} 变量命名规则： 以字母或下划线开头 区分大小写 不能使用保留关键字 为统一风格，建议： 类型名称使用CapWords格式。 模块文件名、函数、方法成员等使用lower_case_with_underscores格式。 全局变量使用UPPER_CASE_WITH_UNDERSCORES格式 避免与内置函数或标准库常用类型同名。 如要检查代码是否违反保留字规则，可使用keyword模块。 >>>import keyword >>>keyword.kwlist ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] >>>keyword.iskeyword(\"yield\") True 注意：以下划线开头名字，代表特殊含义。 模块成员以单下划线开头(_x)，属于私有成员，不会被星号导入。 类型成员以双下划线开头，但无结尾(__x)，属自动重命名私有成员。 以双划线开头和结尾(__x__)，通常是系统成员，应避免使用。 在交互模式下，单下划(_)返回最后一个表达式结果。 内存 Python每个对象，即使是简单数字，在内存中也有标准对象头及保存类型指针和引用计数等信息。如果是字符串、列表等变长类型，还要记录数据项长度及状态数据。 内存总是按变量名来完成“引用传递”。变量名关联会增加计数，反之减少计数。如删除全部名字关联，那么该对象引用计数归零，会被系统回收。 >>>a=1234 >>>import sys >>>sys.getsizeof(a) 28 >>>b=a >>>sys.getrefcount(a) >>>3 >>>del a >>>sys.getrefcount(b) 2 所有对象都有内存管理系统在特定区域统一分配，无论赋值，传参还是返回局部变量都无需关心内存位置，并没有逃逸或隐式复制行为发生。 >>>def test(): x=\"Hello,test\" print(id(x)) return x #返回局部变量 >>>a=test() #对比id结果，确认局部变量被导出 1843195211120 >>>id(a) 1843195211120 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/data_type.html":{"url":"basic/data_type.html","title":"数据类型","keywords":"","body":"数据类型 Python内置的基本数据类型可简单分为数字、序列、映射和集合基类。又根据其实例是否可修改，分可变和不可变。 名称 分类 可变类型 int number N float number N str sequence N bytes sequence N bytearray sequence Y list sequence Y tuple sequence N dict mapping Y set set Y frozenset set N 标准库collections.abc可列出相关类型的抽象基类，及是否可变。 >>>import collections.abc >>>issubclass(str,collections.abc.Sequence) True >>>issubclass(str,collections.abc.MutableSequence) False 本部分有关列表、元组、字典等另开章节来讨论，本部分仅介绍字符串、数字、字节数组等。 字符串 字符串就是一系列字符，可用引号括起来的都是字符串，存储Unicode文本，是不可变序列类型。 >>>s = \"中国\" >>>len(s) 2 >>>hex(ord(\"中\")) '0x4e2d' >>>chr(0x4e2d) '中' >>>ascii(“中国”) \"'\\\\u4e2d\\\\u56fd'\" >>>\"h\\x69, \\u6c49\\U00005B57\" #\\u表示16位unicode，\\U为32位 'hi, 汉字' 引号可以为单引号，双引号。可灵活的使用单引号与双引号。如果字符串包含有单双引号，可使用转义符(\\)。当然，转义符也可以用来转义其他字符，比如制表符\\t,换行符\\n，但如果要使用\\，则需要使用\\\\来表示！ 比如： \"this is a string\" 'this is also a string' 'hello, \"python\"！' \"i'm a good boy!\" 'I\\'m \\\"OK\\\"' '\\tI love python!\\n\\n \\\\but python don\\'t easy!' 如果字符串有很多的\\ ,为了简化，可以使用r''来表示''内部字符串不转义，如 >>>print('\\\\\\t\\\\') #\\ \\ >>>print(r'\\\\\\t\\\\') #\\\\\\t\\\\ 如果有太多的换行\\n，或者每行的字符太长有多行时，可使用'''...'''来输入多行内容，比如： >>>print('''line1 ...line2 ...line3''') line1 line2 line3 字符串操作 操作 说明 示例 title 将字符串首字符大写 \"hello world\".title()=>Hello World lower 将字符串改为小写 \"Hello World\".lower()=>hello world upper 将字符串改为大写 \"hello world\".upper()=>HELLO WORLD rstrip 删除字符串右侧的空格 \" Python \".rstrip()=>' Python' lstrip 删除字符串左侧的空格 \" Python \".lstrip()=>'Python ' strip 删除字符串2侧的空格 \" Python \".strip()=>'Python' 字符串合并 字符串可使用+来拼接，比如： >>>s = \"Hello\" >>>s = s + ' '+'World' >>>print(s) 字符串合并也可混合运算符，比如+为合并，*为重复 >>>3*'un'+'ium' 'unununium' 2个或多个字符串会自动合并，如: >>>'Hello' ' ' 'Py' 'thon' Hello Python 多个动态字符串拼接，优先选择join或format方式。 >>>tmpl = \"/data/{user}/message/{time}.txt\" >>>tmpl.format(user=\"qyuhen\",time=\"2017010\") '/data/qyuhen/message/2017010.txt' >>>import string >>>x = list(string.ascii_uppercase) >>>\"\".join(x) #join比以+来拼接的性能要好的多 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 其他 要输入多行怎么办呢？可使用（）来输入多行，如： >>> text = ('Put several strings within parentheses ... 'to have them joined together.') >>> text 'Put several strings within parentheses to have them joined together.' 字符串其实就是一个元组，可使用元组的一些特性，如： >>>word='Python' >>>word[0] 'P' >>>word[-1] 'n' >>>word[0:2] #切片 'Py' >>>word[-2:] 'on' >>>J+word[1:] 'Jython' >>>s=\"-\"*1024 >>>s1=s[10:100] #片段 >>>s2=s[:] #复制，内容同 >>>s3=s.split(\",\")[0] #分割，内容同 使用in、not in 判断是否包含子串 >>>\"py\" not in \"Python\" True 内置函数len()表示字符串的长度 >>>S='abdde' >>>len(S) 5 转换 除了与数值、unicode转换外，还有不同编码之间转换。Python3使用bytes、bytearray存储字节序列。如要处理BOM信息，需导入codecs模块。 >>>str(1.23e10) '12300000000.0' >>>s=\"汉字\" >>>b=s.encode(\"utf-8\") >>>print(b) b'\\xe6\\xb1\\x89\\xe5\\xad\\x97' >>>b.decode(\"utf-8\") '汉字' >>>import codecs >>>codecs.BOM_UTF16_LE.hex() 'fffe' >>>codecs.encode(s,\"utf-16be\").hex() #按指定BOM转换 '6c495b57' >>>codecs.encode(s,\"utf-16le\").hex() '496c575b' >>>import sys >>>sys.getdefaultencoding() 'utf-8' 格式化 f-strings的支持，使用f前缀标志，解释器解析大括号内的字段或表达式，在上下文名字空间查找同名对象进行替换。格式化遵循format规范。 >>>x = 10 >>>y = 20 >>>f\"{x}+{y} = {x=y}\" #f-strings '10+20=30' >>>\"{}+{}={}\".format(x,y,x+y) #str.format '10+20=30' >>>f\"{type(x)}\" #函数调用 \"\" 完整的format格式化以位置序号或字段名匹配参数进行替换，可添加对齐、填充、精度等控制。从某种角度看，f-strings类似format的增强语法糖。 手工序号和自动序号 >>>\"{0} {1} {0}\".format(\"a\", 10) 'a 10 a' >>>\"{} {}\".format(1, 2) #自动序号 '1 2' 主键 >>>\"{x} {y}\".format(x =100, y= [1, 2, 3]) '100 [1, 2, 3]' 属性和索引 >>>x.name = \"jack\" >>>\"{0.name}\".format(x) #对象属性 'jack' >>>\"{0[2]}\".format([1,2,3,4]) #索引 '3' 宽度、补位 >>>\"{0:#08b}\".format(5) '0b000101' 数字 >>>\"{:06.2f}\".format(1.234) '001.23' 对齐 >>>\"[{:^10}]\".format(\"abc\") #居中 '[ abc ]' >>>\"[{:. 池化 字符串是进程实例数量对多的类型之一，为节约内存，且可省去创建新实例开销，可对内容相同，且不可变的变量名进行池化。在Python中就是实现一个字符串池（intern)，这样好处就是池负责管理实例，只需引用即可使用；从池中返回字符串，只需比较指针就可知内容是否相同，以提高性能。但一旦失去外部引用，池内字符串对象可能会被回收 >>>a=\"abc\" >>>b=\"abc\" >>>a is b False >>>sys.intern(a) is sys.intern(\"abc\") True >>>a = sys.intern(\"hello,world!\") >>>id(a) 2811852698032 >>>id(sys.intern(\"hello,world!\")) 2811852698032 >>>del a #删除外部引用后被回收 >>>id(sys.intern(\"hello,world!\")) #从id值不同可看到是新建后入池的 2811852698224 数字 整数 在Python3中，将int、long这两种类型合并为int,采用变长结构。可处理任意大小整数，并可使用加(+)减(-)乘(*)除-(/)来运算。可以用python当计算器做各种运算。 >>> 3*3 9 >>>3**3 27 >>>3/2 #单斜线为True Division，无论是否整除，总返回浮点数 1.5 >>>3 // 2 #双斜线为False Division，会截掉小数部分，仅返回整数结果 1 >>>(2+10)*2-(10+3) 11 >>>78_654_321 #由于逗号表示tuple语法，可使用下划线便是分割千位位数 78654321 >>>5%2 #取模运算符(mod) 1 >>>divmod(99,5) (19,4) 除了十进制，还可以二进制、八进制、十六进制表示。下划线分隔符号也适用这些进制的字面量。 >>>0b110011 #bin 51 >>>0o12 #oct 10 >>>0x64 #hex 100 >>>0b_11001_1 51 可用内置函数将整数转换为指定进制字符串，或使用int还原，int函数默认为十进制，会忽略空格、制表符等，如指定进制，则可省略相关进制前缀。 >>>int(\"0b1100100\",2) 100 >>>int(\"0o144\",8) 100 >>>int(\"0x64\",16) 100 >>>int(\"64\",16) 100 >>>int(\" 100\\t \") 100 如使用eval也可完成转换，但性能要差很多。 将整数转换为字节数组时需要指定目标字节数组大小，而整数类型是变长结构，故通过二进制位长度来计算，另可通过sys.byteorder来获取当前系统字节序。 >>>x=0x1234 >>>n=(x.bit_length()+8-1)//8 #计算按8位对齐所需的字节数 >>>b=x.to_bytes(n,sys.byteorder) >>>b.hex() '3412' >>>hex(int.from_bytes(b,sys.byteorder)) '0x1234' 布尔 布尔为整数子类型。True，False可当做整数直接使用。 >>>True == 1 True >>> False == 0 True >>>issubclass(bool,int) True >>>isinstance(True,int) True >>>True+1 2 在进行布尔转换时，数字零、空值(None)、空序列和空字典都为False，反之为True。 >>>data=(0,0.0,None,\"\",list(),tuple(),dict(),set(),frozenset()) >>>any(map(bool,data)) False 枚举 Python中没有枚举类型的定义，但可通过标准库来实现。首先定义枚举类型，随后由内部代码生成枚举值实例。 >>>import enum >>>Color = enum.Enum(\"Color\",\"BLACK YELLOW BLUE RED\") >>>isinstance(Color.BLACK, Color) True >>>list(Color) [, , , ] 枚举值不一定为整数，可通过继承，将其指定为任一类型。 >>>class X(enum.Enum): A=\"a\" B=100 C=[1,2,3] >>>X.C 枚举类型的内部以字典方式实现，每个枚举值都有name和value属性。可通过名字或值查找对应枚举实例。按字典规则，值可相同，但名字不可重复。如要避免相同枚举定义，可用enum.unique装饰器。 >>>X.B.name 'B' >>>X.B.value 100 >>>X[\"B\"] >>>X([1,2,3]) 内存 在Python中，小数字都会预先缓存，一般缓存范围为[-5,256]。如超出这个范围，则要新建对象，并内存分配等。 >>>a=-5 >>>b=-5 >>>a is b True >>>a=257 >>>b=257 >>>a is b False 浮点数 带小数的就是浮点数，可表达16到17个小数位。浮点数的小数点位置是可以变的。比如$1.2310^9$和$12.310^8$是相等的。浮点数可使用数学写法，如:1.23，3.14，-9.01，但也可使用科学计数法，如$1.23*10^9$就是1.23e9，0.000012可写成1.2e-5，等等。 >>>tax=12.5/100 >>>price=100.50 >>>price*tax 12.5625 >>>price+_ 113.0625 >>>round(_,2) 113.06 >>>0.1234567890123456789 0.12345678901234568 在交互模式下，变量(_)代表了最后一个表达式。 如对精度有严格要求，则应该固定精度类型。可通过float.hex方法输出实际存储值的十六进制格式字符串。也可通过该方法实现浮点值精度传递，避免精度丢失。 >>>0.1*3 == 0.3 False >>>(0.1*3).hex() '0x1.3333333333334p-2' >>>(0.3).hex() '0x1.3333333333333p-2' >>>s=(1/3).hex() >>>float.fromhex(s) 0.3333333333333333 可固定精度情况下进行比较操作，比如： >>>round(0.1*3, 2)==round(0.3, 2) #避免不确定性，左右都使用固定精度 True >>>round(0.1, 2)*3 == round(0.3, 2) #round返回值作为操作数会导致精度丢失 False 转换 将整数或字符串转换成浮点数很简单，使用内置float函数即可。如超出了有效精度，结果会有差异。 >>>float(\"\\t 100.123\\n \") #会自动处理空白符 100.123 >>>float(\"1.234E2\") #科学计数 123.4 >>>float(\"0.1234567890123456789\") 0.12345678901234568 如浮点数转为整数，可使用内置函数int或标准库函数trunc,floor,ceil等 >>>int(2.6),int(-2.6) (2,-2) >>>from math import trunc,floor,ceil >>>trunc(2.6),trunc(-2.6) #截取小数部分 (2,-2) >>>floor(2.6),floor(-2.6) #往小数字方向去最近整数 (2, -3) >>>ceil(2.6),ceil(-2.6) #往大数字方向取最近整数 (3, -2) >>>round(2.6),round(-2.6) #四舍五入 （3， -3） decimal.Decimal可提供最高28位有效精度，而且不存在近似值问题。 >>>1.1+2.2 3.3000000000000003 >>>from decimal import Decimal >>>Decimal(\"1.1\")+Decimal(\"2.2\") Decimal('3.3') >>>Decimal(0.1) #必须传入准确数值，比如整数或字符，如传入float则精度会丢失 Decimal('0.1000000000000000055511151231257827021181583404541015625') 除非有需求，不建议用Decimal替代float，这样的性能会差很多。可使用getcontext或localcontext来修改Decimal默认的28位精度。 >>>from decimal import Decimal,getcontext,localcontext >>>getcontext() Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[FloatOperation], traps=[InvalidOperation, DivisionByZero, Overflow]) >>>getcontext().prec = 2 #根据上下文修改全局的精度 >>>Decimal(1) / Decimal(3) Decimal('0.33') >>> with localcontext() as ctx: #localcontext限制某个区域精度 ctx.prec =3 print(getcontext().prec) print(Decimal(1)/ Decimal(3)) 3 0.333 四舍五入 因为近似值和精度问题，使用float进行四舍五入会出现操作的不确定性。 >>>round(0.5) 0 >>>round(1.5) 2 由于不确定，可改用Decimal，按需求选取可控的进位。 >>>from decimal import Decimal, ROUND_HALF_UP >>>def roundx(x,n): return Decimal(x).quantize(Decimal(n),ROUND_HALF_UP) >>>roundx(\"0.5\",1) Decimal('1') >>>roundx(\"2.675\",\".01\") Decimal('2.68') 字节数组 从底层实现来看，所有数据都是二进制字节序列，在Python2引入了bytearray字节数组，在Python3新增了只读版本的bytes。字节数组为不可变序列类型。bytes与str有类似的操作。和bytes一次性内存分配相比，bytearray可按需扩张，同样也支持加法、乘法等运算符。 >>>b\"abc\" b'abc' >>>bytes(\"汉字\",\"utf-8\") b'\\xe6\\xb1\\x89\\xe5\\xad\\x97' >>>a=b\"abc\"+b\"def\" >>>a b'abcdef' >>>a.startswith(b\"abc\") True >>>a.upper() b'ABCDEF' >>>b=bytearray(b\"ab\") >>>len(b) 2 >>>b.append(ord(\"c\")) >>>b.extend(b\"de\") >>>b bytearray(b'abcde') >>>b=b+b\"123\"+b\"78\"*3 >>>b bytearray(b'abcde123787878') 内存视图 Python没有指针的概念，另有内存安全模型的限制。要借助名为内存视图的方式来访问底层内存数据。内存视图要求目标对象支持缓冲协议。它直接引用目标内存，没有额外复制行为。因此，可读取最新数据。在目标对象允许下，还可执行写操作。常见支持视图操作的有bytes、bytearray、array.array及NumPy的某些类型。 >>>a = bytearray([0x10,0x11,0x12,0x13,0x14,0x15,0x16]) >>>v = memoryview(a) #完整视图 >>>x = v[2:5] #视图片段 >>>x.hex() '121314' >>>a[3]=0xee #修改原数据，可通过视图观察到 >>>x.hex() '12ee14' >>>x[1]=0x13 #因引用相同内存区域，可通过视图修改原数据 >>>a bytearray(b'\\x10\\x11\\x12\\x13\\x14\\x15\\x16') 视图片段有自己索引范围，注意不要超出限制。是否可通过视图修改数据，需要看原对象是否允许。不如bytes就不可修改。 >>>a = b\"\\x10\\x11\" >>>v = memoryview(a) >>>v[1] =0xEE Traceback (most recent call last): File \"\", line 1, in TypeError: cannot modify read-only memory 如果复制视图数据，可用tobytes、tolist等方法。复制后与原对象无关，不会影响视图本身。 >>>a = bytearray([0x10,0x11,0x12,0x13,0x14,0x15,0x16]) >>>v = memoryview(a) #完整视图 >>>x = v[2:5] #视图片段 >>>b = x.tobytes() #复制并返回视图数据 >>>b b'\\x12\\x13\\x14' >>> a[3]=0xff #不影响复制数据 >>>b b'\\x12\\x13\\x14' © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/list.html":{"url":"basic/list.html","title":"列表","keywords":"","body":"列表 Python内置的列表list是一种有序集合，可随时添加或删除其中元素，可当做队列或栈来使用。用方括号([])来表示列表。如： >>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana'] 如要定义一个空列表，则如下： >>> empty_list = [] >>> empty_list [] >>> len(empty_list) 0 列表内部结构由两部分组成，保存元素数量和内存分配计数的头部，以及存储元素指针的独立数据。所有元素项使用该数组保存指针引用，并不嵌入实际内容。 不同于数组，列表仅存储指针，而对元素内容不关心，故可用不同类型混合。 >>>l=[1,\"abc\",3.14] >>>list(\"abc\") ['a', 'b', 'c'] >>>[x**2 for x in range(3)] [0, 1, 4] >>>[x for x in range(10) if x%2 ==0] #for循环初始数据，if表达式过滤 [0, 2, 4, 6, 8] 列表基本操作 访问列表 列表第一个元素为0，要访问列表只需如数组般访问即可，如： >>>print(fruits[0]) orange 要访问最后一个元素，可指定索引为-1，如: >>>print(fruits[-1]) banana 可对访问的值进行操作，比如： >>>print(fruits[-2].title()) Apple 可使用len来获取列表的长度，如 >>>len(fruits) 7 判断元素是否存在，使用in，而非index方法。 >>>2 in [1,2] True 修改、添加元素 修改列表的元素值很简单，直接将访问的值进行修改就可以了，如： >>>fruits[0] = 'grape' >>>print(fruits) ['grape', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana'] 添加元素，可使用append，如 fruits.append('abc') 这样就将元素添加到了列表的最后。而其他元素并没有受到影响。 插入元素到指定位置，使用insert,如 fruits.insert(1,'abc') 将元素添加到了指定位置，该位置以前元素没有任何影响，该位置以后的索引右移了一位。 也可使用加法或乘法进行添加元素。 >>>a=[1,2] >>>b=a >>>a=a+[3,4] #新建列表对象，然后与a关联 >>>a #a,b结果不同，a指向了新对象 [1,2,3,4] >>>b [1,2] >>>a=[1,2] >>>b=a >>>a +=[3,4] #直接修改a内容 >>>a #a,b结果相同，确认修改原对象 [1,2,3,4] >>>b [1,2,3,4] >>>a is b True “+=”运算符编译器处理为INPLACE_ADD操作，也就是修改原数据，而非创建新对象。效果类似list.extend方法。 删除元素 使用del语句删除元素,比如： del fruits[1] del可删除任何位置的列表元素，但必须有索引。 del也可以删除整个列表，注意删除后列表则不可访问了。 >>>del fruits >>print(fruits) Traceback (most recent call last): File \"\", line 1, in NameError: name 'fruits' is not defined 使用pop()来删除元素，比如： poped_fruits = fruits.pop() pop删除元素后会返回删除的元素。而且pop一定是删除最后一个元素。如果要pop指定位置元素，则比如传入索引，比如： fruits.pop(2) 那么，到底是该使用del语句还是pop()方法了，一个简单判断标准就是：如从列表中删除一个元素，且不再使用它了，就是用del语句；如删除元素后还要继续使用它，则使用方法pop()。 remove删除元素，如果知道要删除元素的值，但不知道位置，则使用remove了。比如： fruits.remove('abc') remove只删除第一个指定的值，如要删除的值在列表中多次出现，则需要使用循环判断来删除了。 列表排序 永久排序 使用方法sort()进行永久排序，比如定义一个列表及排序: >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>cars.sort() >>>print(cars) ['audi', 'bmw','subaru','toyota'] 如要反排序，则使用方法sort()时传入参数reverse=True,如下： >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>cars.sort(reverse=True) >>>print(cars) ['toyota','subaru','bmw','audi'] 临时排序 使用sorted()对列表临时排序，如： >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>print(sorted(cars)) ['audi', 'bmw','subaru','toyota'] >>>print(cars) ['bmw', 'audi', 'toyota', 'subaru'] 同样，可使用reverse=True来进行反排序。 有序列表插入元素 可利用bisect模块，要有序列表插入元素。它使用二分法查找适合位置，可用来实现优先对列或一致性哈希算法。 >>>d=[0,2,4] >>>bisect.insort_left(d,1) #插入新元素后，依然保持有序状态 >>>d [0, 1, 2, 4] 对于自定义符合类型，可通过重载比较运算符(__eq__、__lt__)等实现自定义排序条件。 按设定条件排序 >>>class User: def __init__(self,name,age): self.name = name self.age = age def __repr__(self): return f\"{self.name} {self.age}\" >>>users = [User(f\"user{i}\", i) for i in (3,1,0,2)] >>> users [user3 3, user1 1, user0 0, user2 2] >>>users.sort(key=lambda u:u.age) #使用lambda匿名函数返回排序条件 >>> users [user0 0, user1 1, user2 2, user3 3] 顺序与长度 列表也可以使用reverse()进行修改顺序，调用后会永久修改列表元素的排列顺序，如要恢复，则再次调用。 >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>cars.reverse() >>>print(cars) ['subaru','toyota','audi','bmw'] 列表的长度使用len,如： >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>len(cars) 4 请注意列表的索引，如超出这个范围则会错误，如列表的长度为n,则序号为[-n...n-1]之间。如超出，则会出现如下错误： Traceback (most recent call last): File \"\", line 1, in IndexError: list index out of range 遍历列表 要访问列表的所有元素，可使用for循环。 cars = ['bmw', 'audi', 'toyota', 'subaru'] for car in cars: print(car) 创建列表 使用函数range() 可使用range()来生成一系列数字，如 for value in range(1,5) print(value) range(1,5)会打印数字1-4，range()有3个参数，开始数字，结束数字以及步长，如range(1,10,3)则会打印1,4,7这3个数。 如要生成数字列表，可如下： >>>nums = list(range(1,6)) >>>print(nums) [1,2,3,4,5] 数字列表的简单统计 可使用min,max,sum来对数字列表进行统计。 >>>digits = list(range(1,10)) >>>min(digits) 1 >>>max(digits) 9 >>>sum(digits) 45 列表解析 列表解析就是将for循环以及创建新元素代码合并成一行，病自动附件新元素。如 >>>squares = [values**2 for value in range(1,11)] >>>print(squares) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 列表切片 如果访问列表部分元素，可使用切片，一般要指定第一个元素及最后一个元素的索引，和range()函数差不多吧。如： >>>cars = ['bmw', 'audi', 'toyota', 'subaru'] >>>print(cars[0:3]) ['bmw', 'audi', 'toyota'] 如没有指定第一个索引，则从列表开头开始，如没有指定第二个索引，则到列表结尾结束;当然，索引也可以是负数，如: cars[:3] #等同cars[0:3] 复制后依然指向同一个对象 cars[2:] #等同cars[2:4] cars[:] #等同cars或cars[0:4] cars[-3:] #等同cars[-3,0],打印最后3个 当然切边后的列表也是列表，所以还是可以遍历的，可试下？ 复制列表 复制列表，可使用切片方法来复制。如 cars = ['bmw', 'audi', 'toyota', 'subaru'] new_cars = cars[:] 为啥不直接赋值呢？比如new_cars=cars不行么？好像是可以，但还是有问题。赋值后指向同一个地址，当修改一个列表，则另一个列表也修改了，这是你所预期的？ 返回切片时创建新列表对象，并复制相关指针数据到新数组。除所引用目标相同外，对列表本身的修改(插入、删除等)并不影响。 注意复制的时指针（引用），而非目标元素对象。对列表自身的修改互不影响，但对目标元素对象的修改是共享的。 >>>a=[0,2,4,6] >>>b=a[:2] >>>a[0] is b[0] #复制引用，依然指向同一对象 True >>>a.insert(1,1) #对a列表操作，不影响b >>>a [0,1,2,4,6] >>>b [0,2] 元组 列表是可变的数据集，那么元组呢？元组就是不可变的数据集。元组一旦修改，则不可改变。元组和列表类似，元组是使用圆括号来标识的。定义元组后，可如列表一样进行访问，遍历等，但不可以修改，删除。 因元组为不可变类型，它的指针数组无需变动，故一次性完成内存分配。系统会缓存复用一定长度的元组内存(含指针数组)。元组性能要优于列表。 定义元组 元组定义很列表类似，如： dimensions = (200,500) 如果要定义一个空元组，可如下定义： empty = () 那定义一个有一个元素的元组呢？ >>>t = (1) >>>print(t) 1 怎么打印出来不是元组，是个数字1呢？这是因为()既可以标识元组，也可以表示数学中的小括号，为了消除歧义，必须加一个逗号，，如下定义一个元素的元组： >>>t=(1,) >>>print(t) (1,) >>>type(t) >>>b=(1) >>>type(b) 支持与列表类似运算符操作。但不能修改，总返回新对象， >>> (1,2)+(3,) (1, 2, 3) >>> (1,2)*2 (1, 2, 1, 2) >>> a=(1,2,3) >>> b=a >>> a+=(4,5) #与列表不同，创建新tuple，而不是修改原内容。等同a=a+(4,5) >>> a (1, 2, 3, 4, 5) >>> b (1, 2, 3) 因列表可变，故序号无法与元素对象构成固定映射。但元组不同，相同序号总是同一个对象。故可为序号取“别名”。 >>> User = collections.namedtuple(\"User\",\"name, age\") #创建并指定字段 >>> issubclass(User,tuple) #tuple子类 True >>> u=User(\"qyuhen\",60) >>> u.name,u.age #使用字段名访问 ('qyuhen', 60) >>> u[0] is u.name #序号与“别名”相同 True 数组 数组和列表、元组的本质区别在于：元素单一类型和内容嵌入。 >>> import array >>> a= array.array(\"b\",[0x11,0x22,0x33,0x44]) >>> memoryview(a).hex() '11223344' >>> a=array.array(\"i\") >>> a.append(100) >>> a.append(1.23) Traceback (most recent call last): File \"\", line 1, in TypeError: integer argument expected, got float 可直接存储包括Unicode字符在内的各种数字。如要复合类型，则需用struct,marsha1,pickle等转换二进制字节后再行存储。 与列表类似，数组长度不固定，可按需扩张或收缩内存。 >>> a=array.array(\"i\",[1,2,3]) >>> a.buffer_info() #返回缓冲区内存地址及长度 (2811820040688, 3) >>> a.extend(range(10000)) #追加大量内容后，内存地址和长度变化了。 >>> a.buffer_info() (2811851399072, 10003) 由于可指定数字类型，故数组可节约内存。内容嵌入也避免了对象额外开销，减少了活跃对象数量和内存分配次数。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/dict.html":{"url":"basic/dict.html","title":"字典","keywords":"","body":"字典 字典为内置类型中唯一的映射结构，基于哈希表存储键值对数据。字典与列表和元组不同，存储的信息会更多，更准确。字典使用花括号({})来表示，使用一系列的键-值，可使用键来访问对应的值。值可以是任意数据，但主键必须可哈希类型，故列表、集合等都不可以作为主键使用。 >>> issubclass(list,collections.Hashable) False >>> issubclass(int,collections.Hashable) True >>> issubclass(tuple,collections.Hashable) True 元组为不可变类型，但如引用了可变类型元素，则不能为主键，比如tuple引用了dict,set,list中任意一种则不可为主键。 >>> hash((1,2,3)) 2528502973977326415 >>> hash((1,2,[3,4])) Traceback (most recent call last): File \"\", line 1, in TypeError: unhashable type: 'list' 创建字典，比如: product = {'color': 'red', 'price': 51.00} print(product[color]) print(product[price]) >>>dict(a=1, b=2) {'a': 1, 'b': 2} 初始化键值参数可以元组、列表等可迭代对象方式提供。 >>> kvs=((\"a\",1),[\"b\",2]) >>> dict(kvs) {'a': 1, 'b': 2} 基于动态数据创建，多用zip、map函数或推导式完成。 >>> dict(zip(\"abc\",range(3))) {'a': 0, 'b': 1, 'c': 2} >>> dict(map(lambda k,v:(k, v+10),\"abc\",range(3))) {'a': 10, 'b': 11, 'c': 12} >>> {k: v+10 for k, v in zip(\"abc\", range(3))} #推导式处理数据 {'a': 10, 'b': 11, 'c': 12} 基于已有字典内容扩展或者初始化零值等。 >>> a = {\"a\": 1} >>> b = dict(a, b=1) # 在复制 a 内容的基础上，新增键值对 >>> b {'a': 1, 'b': 1} >>> c = dict.fromkeys(b, 0) # 仅用 b 的主键，内容另设 >>> c {'a': 0, 'b': 0} >>> d = dict.fromkeys((\"counter1\", \"counter2\"), 0) # 显示提供主键 >>> d {'counter1': 0, 'counter2': 0} 添加、修改、删除键值 字典是动态的，可随时添加键值以及修改、删除键值。如： product = {'color': 'red', 'price': 51.00} product['qty'] = 5 product['disc'] = -3 product[price] = 53 del product['disc'] 如主键不存在会出现异常，可先用in、not in语句判断，或用get方法返回默认值。 >>> x = dict(a=1) >>> x[\"b\"] Traceback (most recent call last): File \"\", line 1, in KeyError: 'b' >>> \"b\" in x False >>> x.get(\"b\",100) # 主键b不存在，返回默认值100 100 >>> x.get(\"a\",100) # 主键a存在，返回实际内容 方法get的默认参数仅返回，不影响字典内容。但如想字典插入默认值，则可使用setdefault。 >>> x = {} >>> x.setdefault(\"a\", 0) #如果有a,返回实际内容，否则新增{a:0}键值对 0 >>> x {'a': 0} >>> x[\"a\"] = 100 >>> x.setdefault(\"a\", 0) 100 字典不支持加法、乘法、大小等运算，但可比较内容是否相同。 >>> {\"a\": 1, \"b\": 2} == {\"a\": 1, \"b\": 2} True 遍历字典 如列表、元组一样，可遍历字典的所有键值。 product = {'color': 'red', 'price': 51.00} for key, value in product.items: print(\"Key:\"+key) print(\"\\nValue:\"+value) 字典的所有key实际组成了一个列表，你可如列表一样进行遍历： for key in product.keys(): print(\"Key:\"+key) 同样，所有的value也组成了列表，可通过product.values()访问。 既然字典的keys()、values()都是列表，那一样适用列表的属性，比如可使用sorted进行临时排序。 嵌套 字典内的元素不一定就是固定一种类型，其值可以是字符串，数字，布尔值，元组，列表，甚至字典。也就是字典中可嵌套列表或字典，同样，列表也可嵌套字典、列表等。 product1 = {'color':'red','price':53} product2 = {'color':'blue','price':44} products = [product1,product2] for product in products: print(product) pizza = { 'crust': 'thick', 'toppints': ['mushrooms', 'extra cheese'], } users = { 'john': { 'first': 'jack', 'last': 'zhao' }, 'rose': { 'first': 'rose', 'last': 'li' }, } 视图 Python3默认以视图关联字典内容，这样既可避免复制开销，又可同步观察字典变化。 >>> x = dict(a=1,b=2) >>> ks=x.keys() #主键视图 >>> \"b\" in ks #判断主键是否存在 True >>> for k in ks: print(k, x[k]) #利用视图迭代字典 ... a 1 b 2 >>> x[\"b\"]=200 #修改字典内容 >>> x[\"c\"]=3 #没有则新增 >>> for k in ks: print(k, x[k]) #视图同步变化 ... a 1 b 200 c 3 字典如直接引用则可能被接收方修改，如复制则无法获取字典变化。如使用视图，则可同步读取字典内容而无法修改。且可选择不同粒度内容进行传递，如此可将接收方限定为指定模式下的观察者。 >>> def test(d): #传递键值视图(items)，只能读取，不可修改 ... for k, v in d: ... print(k, v) ... >>> x=dict(a=1) >>> d=x.items() >>> test(d) a 1 视图还支持集合运算，以弥补字典功能上的不足。 >>> a = dict(a=1,b=2) >>> b = dict(c=3,b=2) >>> ka=a.keys() >>> kb=b.keys() >>> ka & kb #交集：在a、b中同时存在 {'b'} >>> ka | kb #并集：在a或b中存在 {'b', 'c', 'a'} >>> ka - kb #差集：仅在a中存在 {'a'} >>> ka ^ kb #对称差集：仅在a或仅在b中出现，等同“并集-交集” {'c', 'a'} 利用视图集合运算，可简化某些操作。如，只更新，不新增。 >>> a = dict(a=1, b=2) >>> b = dict(b=20, c=3) >>> ks = a.keys() & b.keys() # 交集，也就是a中必须存在的主键 >>> a.update({k:b[k] for k in ks}) >>> a {'a': 1, 'b': 20} 扩展 标准库collections的默认字典(defaultdict)类似setdefault包装。当主键不存在，调用构造参数提供的工厂函数返回默认值。 >>> d = collections.defaultdict(lambda: 100) >>> d[\"a\"] 100 >>> d[\"b\"] +=1 >>> d defaultdict( at 0x00000171FD7AA840>, {'a': 100, 'b': 101}) 有序字典(OrderedDict)会记录主键首次插入的次序。 >>> d = collections.OrderedDict() >>> d[\"z\"] =1 >>> d[\"a\"] =2 >>> d[\"x\"] =3 >>> for k, v in d.items(): print(k, v) z 1 a 2 x 3 与前面介绍不同，计算器(Counter)对不存在主键返回0，但不会新增。 >>> d = collections.Counter() >>> d[\"a\"] 0 >>> d[\"b\"]+=1 >>> d Counter({'b': 1}) 链式字典(ChainMap)以单一接口访问多个字典内容，其自身并不存储数据。读操作按参数顺序依次查找各字典，但修改操作(增、改、删)仅针对第一字典。 >>> a = dict(a=1, b=2) >>> b = dict(b=20, c=30) >>> x = collections.ChainMap(a, b) >>> x[\"b\"], x[\"c\"] #按顺序命中 (2, 30) >>> for k,v in x.items(): print(k, v) #遍历所有字典 ... b 2 c 30 a 1 >>> x[\"b\"] = 999 #更新，命中第一字典 >>> x[\"z\"] = 888 #新增，命中第一字典 >>> x ChainMap({'a': 1, 'b': 999, 'z': 888}, {'b': 20, 'c': 30}) 链式字典查找次序可被调用链的后续函数读取，这也是继承的体现。而修改操作限定在当前第一字典中，故不会影响父级字典的同名主键设置。 >>> root = collections.ChainMap({\"a\": 1}) >>> child = root.new_child({\"b\": 200}) >>> child[\"a\"] =100 >>> child ChainMap({'b': 200, 'a': 100}, {'a': 1}) >>> child.parents ChainMap({'a': 1}) 集合 集合存储非重复对象。这里的非重复是指不是同一对象外，值也不能相等。 判重公式：(a is b) OR (hash(a) == hash(b) AND a==b ) 如不是同一对象，则先判断哈希值，然后比较内容。受限哈希算法，不同内容可能返回相同哈希值(哈希碰撞)。为啥要先比较哈希值呢？首先，与内容相比，整数哈希值比较性能要高很多，其次，哈希值不同，内容肯定不同，则不需继续比较内容。 >>> a=1234 >>> b=1234 >>> a is b #内容同，但不是相同对象 False >>> s={a} #创建集合，初始化元素a >>> b in s #用内容相同的b进行判重 True 按操作方式，集合分可变(set)和不可变(frozenset)两种，内部实现相同。用数组实现的哈希表存储元素对象引用，这也就要求元素必须为可哈希类型。 创建 与字典语法相同，使用花括号，但初始化数据非键值对。 >>> type({}) # 没有初始化值，表示创建空字典 >>> type({\"a\":1}) #字典：键值对 >>> type({1}) #集合 >>> set({1, \"a\", 1.0}) {1, 'a'} >>> frozenset(range(3)) frozenset({0, 1, 2}) >>> {x+1 for x in range(6) if x%2 == 0 } //推导式创建 {1, 3, 5} >>> s = {1} >>> f = frozenset(s) # set与frozenset转换 >>> set(f) {1} 操作 支持大小、相等运算符。 >>> {1, 2} > {2, 1} False >>> {1, 2} == {2, 1} True 子集判断不可用in、not in语句，它仅用来检查是否包含某个元素。 >>> {1, 2} >> {1, 2, 3} >= {1, 2} # 超集：issuperset True >>> {1, 2} in {1, 2, 3} # 判断是否包含{1， 2}单一元素 False 集合作为初等数学概念，重点是并差集运算。 交集： 同时属于A、B两个集合。 并集：A、B的所有元素。 差集：仅属于A，不属于B。 对称差集：仅属于A，加上仅属于B，相当“并集 - 交集”。 >>> {1, 2, 3} & {2, 3, 4} #交集：intersection {2, 3} >>> {1, 2, 3} | {2, 3, 4} #并集：union {1, 2, 3, 4} >>> {1, 2, 3} - {2, 3, 4} #差集: difference {1} >>> {1, 2, 3} ^ {2, 3, 4} #对称差集：symmetric_difference {1, 4} 集合运算还可与更新操作一起使用。 >>> x = {1, 2} >>> x |= {2, 3} >>> x {1, 2, 3} >>> x = {1, 2} >>> x &= {2, 3} >>> x {2} 删除操作不能用remove，可能引发异常，可改用discard。 >>> x = {2, 1} >>> x.remove(2) >>> x.remove(2) Traceback (most recent call last): File \"\", line 1, in KeyError: 2 >>> x.discard(2) 自定义类型 自定义类型虽可是哈希类型，但默认实现并不足以完成集合去重操作。 >>> class User: ... def __init__(self,uid,name): ... self.uid=uid ... self.name=name >>> issubclass(User, collections.Hashable) True >>> u1 = User(1, \"user1\") >>> u2 = User(1, \"user1\") >>> s=set() >>> s.add(u1) >>> s.add(u2) >>> s {, } 根本原因是默认实现的__hash__方法返回随机值，而__eq__仅比较自身。为符合逻辑需求，需重载这2个方法。 >>> class User: ... def __init__(self, uid, name): ... self.uid =uid ... self.name=name ... def __hash__(self): #针对uid去重，忽略其他字段 ... return hash(self.uid) ... def __eq__(self, other): ... return self.uid == other.uid ... >>> u1 = User(1,\"user1\") >>> u2 = User(1,\"user1\") >>> s=set() >>> s.add(u1) >>> s.add(u2) >>> s {} >>> u1 in s True >>> u2 in s True © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/if.html":{"url":"basic/if.html","title":"流程控制","keywords":"","body":"流程控制 IF语句 If语句就是进行流程判断，然后做出相应的处理。比如： cars = ['audi','bmw','subaru','toyota'] for car in cars: if car == 'bmw': print(car.upper()) else: print(car.title()) 条件测试 使用 == 来判断是否相等，如: car = 'bmw' car == 'bmw' # True car = 'Audi' car == 'audi' # False car.lower() == 'audi' # True 使用!=来判断是否不相等 car = 'bmw' car !='audi' #True 上面都是字符串比较，那么数字呢？除了 ==，!=外，还有小于（)，大于等于(>=)，小于等于( 如果是列表呢？就可以使用in了。如: cars = ['audi','bmw','subaru','toyota'] 'bmw' in cars # True 'apple' not in cars # True 多条件判断 使用and 和or 来进行多条件判断。 age=10 age>=6 and age10 and age=10 or ageif-else语句 当条件通过执行一个操作，没通过则执行另一个操作时，就要用到if-else语句了。 age =17 if age>=18: print('你可以选举了') else: print('对不起，你还不能选举') if-elif-else语句 多条件判断，当所有条件不满足，则执行else语句，比如： age =12 if age>4: print('免费') elif age© 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/loop.html":{"url":"basic/loop.html","title":"循环","keywords":"","body":"循环 在列表、元组及字典中经常都用到了for循环，用来对集合中每个元素进行遍历。下面介绍while循环。 while循环 while循环就是不断运行，直到指定条件不满足为止。比如： current =1 while current 在使用Input()函数进行输入时，希望能让用户不停输入，直到约到quit后退出。那么可使用while循环来实现。如： message = \"\" while message != 'quit': message = input(\"请输入，直到'quit'退出\") if message !='quit': print(message) break退出循环 在while循环中，可不管任何条件，都可使用break来退出循环。比如： while True: message = input(\"请输入，直到'quit'退出\") if message == 'quit': break else: print(message) 当然，除了while循环，在for循环中，一样可使用break来退出循环。 continue继续循环 如要返回循环开头，并根据条件测试结果来决定是否继续执行循环，则可使用continue语句。如，从1到10 ，只打印奇数的循环： num = 0 while num 尽量避免无限循环，在交互的情况下，如无限循环，可使用Ctrl+C来退出，然后修改代码。 while处理列表和字典 for循环可遍历列表，但不可修改列表。如要移动或者修改或者删除列表时，那么最好用while循环。 src = ['a','b','c'] dst = [] while src: current = src.pop() dst.append(current) for d in dst: print(d.title()) ## 使用remove pets = ['dog','cat','dog','fish','cat','rabbit'] while 'cat' in pets: pets.remove('cat') © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/function.html":{"url":"basic/function.html","title":"函数","keywords":"","body":"函数 函数就是带名字的代码块，用来完成一些具体的事情。要执行函数定义的特定任务时，就要调用该函数。定义函数是为了在程序中能多次调用，而无需反复编写代码。使用函数，会让程序编写、阅读、测试、DEBUG都变得容易。 定义函数 下面定义一个简单函数，如： def greet(user): print(\"Hello \"+user.title()) greet('Python') 上面函数传递了一个参数，那么在函数greet中，user就是参数，也可以称为形参。而调用greet('Python')中的’Python‘就是实参。greet('Python')就是将实参'Python'传递给函数greet中的形参user中。 参数 上面简单解释了实参与形参。那么如果有多个参数怎么传递呢？调用函数时，每个实参都需要关联到函数定义的形参中，最简单的关联方式就是基于实参的位置。比如： def desc_pet(type,name): print(\"宠物类型为：\"+type) print(\"宠物名称为：\"+name) desc_pet('hamster','harry') desc_pet('cat','jerry') 注意：函数调用实参顺序和函数定义的形参顺序要一致，不然就会错误。 如果不关注参数位置，则可通过形参关键字来调用。比如： desc_pet(name='micky',type='mouse') 使用关键字实参时，必须要准确的指定函数定义中的形参名。 定义函数时，还可以指定默认值，如不传入实参，则按缺省值来提供。比如： def desc_pet(name,type='dog'): print(\"宠物类型为：\"+type) print(\"宠物名称为：\"+name) desc_pet('harry') 有默认值的形参最好放在最后，这样进行位置传送时就不宜出错，不然要就需要指定形参名。 返回值 函数可以处理后返回一个或一组值。函数返回的值称为返回值。必须使用return来返回，一旦返回，则函数停止执行。 def format_name(first_name,last_name): return fist_name+' '+last_name print(format_name('jack','ma')) 如果上面函数需要提供中间名，而中间名并非必须呢？也就是希望参入的实参是可选的，那上面函数可修改为： def format_name(first_name,last_name, mid_name=''): return fist_name+' '+mid_name+ ' '+last_name print(format_name('john','lee','hooker')) print(format_name('jack','ma')) 如果要将返回值返回为一个更复杂的类型，比如字典呢？那上面函数可修改为： def format_name(first_name,last_name, mid_name=''): person = {'first':first_name,'last':last_name,'mid':mid_name,} return person 传递列表参数 形参可接收任何类型，如传入列表，字典等。如果传入列表后，希望不能修改列表怎么处理呢？那么传入实参时，可传入实参的副本。比如: def love_pets(pets): for pet in pets: print(pet) pets = ['dog','cat','goldfish'] love_pets(pets) #传入的实参可在函数中修改 love_pets(pets[:]) #传入实参列表的副本到函数，不影响实参。 向函数传递列表副本可保留原始列表的内容，但除非有充分理由需要传递副本，否则还是传递原始列表给函数，因为函数使用现成列表可避免花时间和内存来创建副本，从而提供效率。 任意数量参数 有些函数定义时并不知道有多少实参，那么函数定义形参时加入*，表示可接收任意数量参数，比如： def make_pizza(*toppings): print(toppings) make_pizza('pepperoni') make_pizza('mushrooms','green peppers','extra cheese') 如函数接收不同类型实参，那么可接纳任意数量实参的形参必须放在最后，比如: def make_pizza(size,*toppings): print(size) print(toppings) make_pizza(16,'pepperoni') make_pizza(12,'mushrooms','green peppers','extra cheese') 有时，需要接收任意数量的实参，而且不知道会传递给函数什么参数。这时，可将函数编写成接收任意数量键值对，使用**来标识。比如: def build_profile(first,last,**user_info): profile ={} profile['first_name']=first profile['last_name']=last for key, value in user_info.items(): profile[key]=value return profile user_profile = build_profile('albert','lee',location='hubei',field='physics') print(build_profile) 编写函数时，可以各种方式混合使用位置实参，关键字实参和任意数量参数。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/class.html":{"url":"basic/class.html","title":"类","keywords":"","body":"类 面向对象编程是最流行的编写软件方法之一。在面向对象编程中，基于类来创建对象就是很通用的方法。根据类来创建对象被称为实例化。 创建和使用类 使用类可模拟任何东西。比如简单类Dog，如下： class Dog(): def __init__(self, name, age): self.name = name self.age = age def sit(self): print(slef.name.title()+' is now sitting.') def roll_over(self): print(self.name.title()+\"rolled over!\") 在Python中，类一般定义时名称都是首字母大写的。类定义括号为空，表示从空白创建这个类。 方法__init__()时一个特殊方法，在类创建新实例时，会自动运行它，开头和末尾有两个下划线，这是一种约定，以便与自己定义的普通方法发生名称上的冲突。 在定义方法时，形参self必不可少，还必须在其他形参前面。这是因为Python在调用方法时会自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能访问类中的属性和方法。所以每个类所定义的方法第一个参数都是self。 以上是创建类，那么怎么调用呢？也就是需要根据类创建实例，再通过实例来调用相应的方法。比如: my_dog = Dog('willie', 6) print(\"My dog's name is \"+my_dog.name.title()+\"!\") print(\"My dog's is \"+str(my_dog.age)+\" years old.\") my_dog.sit() my_dig.roll_over() 上面演示了怎么通过实例来调用对象的属性与方法。那怎么修改属性呢？第一是直接修改，第二是通过方法来修改。比如： my_dog.age = 7 通过方法就需要在类中定义方法。接上面定义的类（部分代码省略）： def setAge(self, age): self.age = age my_dog.setAge(7) 虽然可通过上面方法来控制类修改类中的属性，但为确保安全，还是要进行必要的基本检测，以保障类的安全。 继承 类最大的好处就是可以继承。一个类继承另一个类时，它自动获得另一个类的所有属性和方法，原有类为父类，新类为子类。子类继承父类所有属性和方法，还可以定义自己属性和方法。 class Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year class ElectricCar(Car): def __init__(self, make, model, year): super.__init__(make, model, year) self.battery_size = 70 对于父类方法，只要不符合子类模拟的行动，都可以重写。可在子类定义一个很父类同名的方法，就可重写父类方法。 使用继承，可让子类保留父类继承而来的精华，并剔除不需要的东西。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/exception.html":{"url":"basic/exception.html","title":"异常","keywords":"","body":"异常 在执行期出现的错误就是异常。当Python在处理发生的错误时会创建一个异常对象。如果编写了处理该异常的代码，则程序继续运行，如未对异常进行处理，则程序停止，并显示traceback，其中会包含异常的报告。 异常使用try-except代码块来处理。比如 print(10/0) Python会显示如下traceback： Traceback (most recent call last): File \"\", line 1, in ZeroDivisionError: division by zero 但使用了try-except代码块处理异常后，则不同了，如下： try: print(10/0) except ZeroDivisionError: print(\"you can't divide by zero!\") 这样就不会出现traceback了，会正常打印一条友好的错误消息。 如发生错误，而程序还没有完成，则妥善处理错误会很重要。如处理的好，则程序不会崩溃。 try-except-else代码块： 上面介绍了try-except代码块，可用来提高程序处理错误的能力。try代码块错误后会进入到except代码块，但执行成功后会进入到else代码块中。只有能引发异常的代码才需要放在try语句中。如try语句执行成功后需要运行代码应该放在else代码块中。except代码块是程序尝试运行try代码块引发指定异常后进行处理，如果想什么都不处理，将错误一声不吭的处理掉，可使用代码pass。 文件处理时很容易出现错误，比如文件找不大，这时就会出现FileNotFoundError异常，那么在处理文件时就需要处理FileNotFoundError异常。比如: filename = 'a.txt' try: with open(filename) as f： contents = f.read() except FileNotFoundError: print('the file '+filename+' does not exist') else: print(contents) © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/inout.html":{"url":"basic/inout.html","title":"输入输出","keywords":"","body":"输入输出 有时程序必须等待用户输入才可继续工作，那么怎么通过获取用户输入来控制程序呢？ input() 函数input()会让程序暂停等待用户输入，然后将输入作为变量存储以便用户使用。比如： name = input(\"请问您怎么称呼呢？请输入您的称呼：\") print(\"Hello\" + name+\"!\") age = input(\"您多大了呢？请输入年龄：\") print(age) 好了，上面年龄显示出来是字符串形式，比如我输入年龄时输入了非数字字符，或者年龄要以数字来进行计算或判断呢？这可使用int()来转换。 age = input(\"您多大了呢？请输入年龄：\") age = int(age) age >=18 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/file.html":{"url":"basic/file.html","title":"文件操作","keywords":"","body":"文件操作 可以用Python来处理文件，让程序能读取文件内容并进行分析或处理。 文件读取 文本文件可以存储很多信息。当需要分析或修改存储文件中的信息时，就需要先读取文件。读取文件会首先将信息读取到内存中，为此，可一次性读取文件全部内容，也可每次一行的逐步读取。 比如有的写有圆周率的文本。内容忽略，可自动定义，就是有写有圆周率的几行数字吧，比如这个文件叫pi.txt。 with open('pi.txt') as f: contents = f.read() print(contents) 注意，使用关键字with，则不需考虑文件关闭，在访问完成后就自动将其关闭了。如果不使用with来打开文件，则需要显式的调用close()来关闭文件。 在打开文件时，并没有指定路径，那Python会在当前目录，也就是你代码保存为py文件所在的路径来查找文件。 可使用绝对路径以及相对路径。绝对路径就是准确指出文件路径，也就是绝对文件路径。相对路径是相对当前py文件所在路径的。同时要注意操作系统，如linux的文件路径为(\\)，为window的文件路径为(/)。 上面代码是一次读取，如要逐行读取，可如下： with open('pi.txt') as f: for line in f: print(line) 读取文件时，Python将其中文本都读取为字符串。如要将其作为数值使用，可使用int()将其转为整数，或使用函数float()将其转为浮点数。 Python可处理大文本。只要内存足够大，多少数据都能处理。 写入文本 要将内容写入到文件，一样调用open()，不过需要指定另一个实参。比如： with open('pi.txt', 'w') as f: f.write(\"3.1415926535\") 这里介绍下open()函数，第一个实参为文件名称，第二个为操作模式，缺省为'r'，可省略，所以读取时省略了这个实参。这个实参如下：读取模式('r')，写入模式(‘w’)，附件模式('a')，读取和写入模式('r+')。 如要写入文件不存在，则会自动创建它。然后，以写入模式打开文件时如指定文件已经存在了，那么会返回文件对象前清空该文件。 如写入文件内容为多行，必须在每行末尾加上换行符\\n。为了格式好看，也可使用空格、制表符、换行符等来设置输出格式。 如果要将文件添加内容，而不是覆盖以前的内容，请以附加模式来打开文件。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"basic/unittest.html":{"url":"basic/unittest.html","title":"单元测试","keywords":"","body":"单元测试 编写完代码后，只有通过了测试，才可确定代码是否按要求完成指定的工作。 函数测试 比如有段代码如下，保存在name.py中。 def get_name(first,last): full_name = first+’ ‘+last return full_name.title() 要进行测试比如导入模块unittest以及要测试的函数。在创建一个unittest.TestCase类，并编写一系列方法对函数进行不同测试。 import unittest from name import get_name class NamesTestCase(unittest.TestCase): def test_full_name(self): name = get_name('janis','joplin') self.assertEqual(name, 'Janis Joplin') unittest.main() 上面使用了unittest类常用功能之一：断言方法。断言方法用来核实得到的结果是否与预期的结果一致。如果相同，则测试通过，否则，则测试通不过。 如果测试未通过怎么办呢？需要检查条件是否错误，如果条件正确，而结果不对，则函数可能有问题，修改代码，然后继续测试，知道符合预期结果。 测试类 unittest.TestCase类中提供了很多断言方法。断言方法检查应该满足的条件是否满足，如果满足，则程序正确，如果不满足，则程序可能代码有问题或者发生了异常。下面表格介绍断言方法： 方法 用途 assertEqual(a, b) 核实 a == b assertNotEqual(a, b) 核实 a != b asserTrue(x) 核实x为True assertFalse(x) 核实x为False assertIn(Item, list) 核实item在list中 assertNotIn(Item, list) 核实item不在list中 除了断言方法，还有个方法setUp()，该方法只需在测试类中创建测试对象一次，然后在每个测试方法中就可使用它了。也就是setUp()方法可实例要初始的类以及初始化类的属性，以便在测试方法中能重复使用实例，而不需要重复创建。 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"module/":{"url":"module/","title":"内置模块","keywords":"","body":"内置模块 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"common/":{"url":"common/","title":"常用模块","keywords":"","body":"常用模块 © 2019 Dastone Deng . All rights reserved.本站访客数 人次"},"common/requests.html":{"url":"common/requests.html","title":"requests","keywords":"","body":"requests © 2019 Dastone Deng . All rights reserved.本站访客数 人次"}}