# 基础

在Python中，要了解class以及instance。所有的变量都有自己的class，一旦赋值以后就实例化(instance)了。每个变量都是自己的唯一ID值。

```
>>>id(123)
140734734037456
>>>id('abc')
2390831392056
```

不同Python实现使用了不同算法，CPython用内存地址作为ID值。所以ID不适合为全局身份标识，因为内存地址有可能会被重复使用。比如：

```
>>> a = 123
>>>id(a)
140734734037456   #和上面id(123)的地址是一致的
>>>c=a
>>>id(c)
140734734037456
```

可用type返回实例所属类型。比如：

```
>>>type(123)
<class 'int'>
>>>type(1.23)
<class 'float'>
>>>type(True)
<class 'bool'>
>>>type("hello")
<class 'str'>
```

要判断实例是否属于某个类型，可使用isinstance函数，比如：

```
>>>isinstance(123,int)
True
>>>isinstance(1.23, float)
True
```

注意，所有类型都属于类型object。object是所有类型的基类，提供了一些基本属性及操作方法等，所有类型都继承自object。但所有类型都是有type创建的，这和继承无关，如：

```
>>>issubclass(int, object)
True
>>>id(int)
140734733558240
>>>type(int)
<class 'type'>
>>>isinstance(int, type)
True
>>>issubclass(type,object)
True
```

类型对象属于创建者这样特殊存在。默认情况下，它们在解释器首次载入时自动生成，生命周期与进程相同，且仅有一个实例。

#### 变量

变量是具有特别格式的内存，而变量名则为内存别名，变量名与指针是不同的。Python是一种动态类型语言，也就是只有在运行时才知道变量名的类型。所以变量名必须和目标对象关联才可以，而最直接关联就是赋值，而后对变量名引用都解释为对目标对象的操作。

名字空间(namespace)是上下文环境中专门用来存储名字和目标引用关联的容器。在Python中，每个模块都有一个全局名字空间。而根据作用域，又会有当前名字空间或本地名字空间。内存函数globals和locals分别返回全局名字空间和本地名字空间字典。globals一般固定指向模块名字空间，而locals则指向当前作用域空间。

了解了名字空间，就知道变量名只是字符串主键，自身的数据结构中并没有任何目标对象信息。通过变量名访问目标对象，就是以名字为主键去空间字典中读取目标对象指针引用。所以，变量名可重新关联另一对象，而不在乎其类型是否与以前相同。

```
>>>x=100
>>id(x)
140705733701360
>>>globals()
{...,'x':100}
>>>x="abc"     #重新关联其他对象，没有类型限制
>>>id(x)       #通过输出id，可看出关联新对象，而非修改原对象内容
1843192063288
>>>globals()     #名字空间里引用发生了变更
{...,'x':'abc'}
>>>locals()     #模块作用域中，可通过id查看，globals与locals相同
{...,'x':'abc'}
```

赋值操作只是变量名在名字空间里重新关联，而非修改对象。单个对象可以同时又多个变量名。可用is来判断2个变量名是否引用同一对象。相等操作符会判断值是否相同。

```
>>>a = 2345    #请使用大数字，小数字常量会被缓存
>>>b = a
>>>a is b
True
>>>c = 2345
>>>a is c
False
>>>a == c
True
>>>globals()              #2345会有不同变量名
{...,'a':'2345','b':'2345','c':'2345'}
```

变量命名规则：

+ 以字母或下划线开头

+ 区分大小写

+ 不能使用保留关键字

为统一风格，建议：

- 类型名称使用CapWords格式。

- 模块文件名、函数、方法成员等使用lower_case_with_underscores格式。

- 全局变量使用UPPER_CASE_WITH_UNDERSCORES格式

- 避免与内置函数或标准库常用类型同名。

如要检查代码是否违反保留字规则，可使用keyword模块。

```
>>>import keyword
>>>keyword.kwlist
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
>>>keyword.iskeyword("yield")
True
```

注意：以下划线开头名字，代表特殊含义。

* 模块成员以单下划线开头(_x)，属于私有成员，不会被星号导入。

* 类型成员以双下划线开头，但无结尾(__x)，属自动重命名私有成员。

* 以双划线开头和结尾(\_\_x\_\_)，通常是系统成员，应避免使用。

* 在交互模式下，单下划(_)返回最后一个表达式结果。

#### 内存

Python每个对象，即使是简单数字，在内存中也有标准对象头及保存类型指针和引用计数等信息。如果是字符串、列表等变长类型，还要记录数据项长度及状态数据。

内存总是按变量名来完成“引用传递”。变量名关联会增加计数，反之减少计数。如删除全部名字关联，那么该对象引用计数归零，会被系统回收。

```
>>>a=1234
>>>import sys
>>>sys.getsizeof(a)
28
>>>b=a
>>>sys.getrefcount(a)
>>>3
>>>del a
>>>sys.getrefcount(b)
2
```

所有对象都有内存管理系统在特定区域统一分配，无论赋值，传参还是返回局部变量都无需关心内存位置，并没有逃逸或隐式复制行为发生。

```
>>>def test():
		x="Hello,test"
		print(id(x))
		return x                    #返回局部变量

>>>a=test()                         #对比id结果，确认局部变量被导出
1843195211120
>>>id(a)
1843195211120
```

